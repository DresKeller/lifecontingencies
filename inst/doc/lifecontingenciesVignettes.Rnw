
\documentclass[nojss]{jss}

\usepackage[OT1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lifecon}
%\usepackage{draftwatermark}
%\SetWatermarkText{Draft}
%\SetWatermarkScale{1.5}

%\usepackage{myVignette}

%\VignetteIndexEntry{An introduction to lifecontingencies package}
%\VignetteKeywords{vig1}
%\VignettePackage{lifecontingencies}
% need no \usepackage{Sweave.sty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Giorgio Alfredo Spedicato, Ph.D}
\title{The \pkg{lifecontingencies} Package. A package to perform financial and actuarial mathematics analysis}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Giorgio Alfredo Spedicato, Ph.D} %% comma-separated
\Plaintitle{The lifecontingencies package} %% without formatting
\Shorttitle{A package to perform financial and actuarial mathematics analysis} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  \pkg{lifecontingencies} performs financial and actuarial mathematics calculations to model life contingencies insurance. Its functions are able to 
  determine both the expected value and the stochastic distribution of insured benefits. Therefore they can be used both to price new insurance products and to 
  determine portolios' risk based capital requirements.\\ 
  This paper briefly summarizes the theory regarding life contingencies, that is represented by concepts of financial and actuarial mathematics. 
  Then it shows how \pkg{lifecontingencies} functions represent a perfect cookbook to perform life insurance actuarial analysis and related 
  stochastic simulations throught applied examples.
}
\Keywords{life tables, financial mathematics, actuarial mathematics, life insurance, \proglang{R}}
\Plainkeywords{life tables, financial mathematics, actuarial mathematics, life insurance, R} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Giorgio Alfredo Spedicato\\
  StatisticalAdvisor\\
  Via Firenze 11
  20037 Italy\\
  Telephone: +39/334/6634384\\
  E-mail: \email{lifecontingencies@statisticaladvisor.com}\\
  URL: \url{www.statisticaladvisor.com}
}


%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{document}

<<echo=FALSE, results=hide>>=
	options(prompt = "R> ", continue = "+ F ", width = 70, useFancyQuotes = FALSE)
	library(lifecontingencies)
	source("calculations1.R")
	source("calculations2.R")
@

\maketitle

\section{Introduction}
As of April 2012, \pkg{lifecontingencies} appears to be the first \proglang{R} package that deals with life insurance evaluation.
 Some actuarial packages have been already available in \proglang{R}, however most of these packages mainly focus non-life actuaries. 
  In fact non - life insurance modeling uses more data analysis and applied statistical modelling than life 
 insurance does. Functions to fit loss distributions and to perform credibility 
analysis are provided within the package \pkg{actuar}, \cite{Dutang2008}. Package \pkg{actuar} represents the computational side of the classical actuarial textbook Loss Distribution, \cite{klugman2009loss}. 
The package \pkg{ChainLadder}, \cite{chainLadder}, provides functions to estimate unpaid loss reserves for P\&C insurances.
GLM models, widely used in non - life insurance pricing, can be fit by functions bundled in the base \proglang{R} distribution. More advanced predictive models used by actuaries, e.g., GAMLSS and 
Tweedie regressions, can be fit using specifically developed packages as \pkg{gamlss}, \cite{gamlssPkg}, and \pkg{cplm}, \cite{cplmPkg}, packages respectively.\\
Life insurance evaluation models demographic and financial data, mainly . \proglang{R} has a dedicated view to packages specifically tailored to financial analysis. But, few packages that 
handle demographic data have been published yet. For examples, relevant packages that perform demographic analysis are \pkg{demography}, \cite{demographyR}, and \pkg{LifeTables}, \cite{LifeTableR}.
Packages \pkg{YieldCurve}, \cite{YieldCurveR}, and \pkg{termstrc}, \cite{termstrcR}, can be used to perform interest 
rate analysis. However, no package exists that performs life contingencies calculations, as of April 2012.\\

Numerous commercial software specifically tailored to actuarial analysis are available in commerce, on the other hand. 
Moses and Prophet are currently the leading actuarial softwares for life insurance modelling. \pkg{lifecontingencies} package aims to represent the R 
computational side of the concepts exposed in the classical Society of Actuaries Actuarial Mathematics book, \cite{bowers1997actuarial}. Since 
life contingencies theory grounds on demography and classical financial mathematics, w have made an exstensive use of \cite{mathFinAct} and 
\cite{broverman2008mathematics} textbooks as references.

The paper has been structured as follows: section \ref{sec:statistics} outlines the statistical and financial mathematics theory
regarding life contingencies, section \ref{sec:structure} overviews the structure of the \pkg{lifecontingencies} package, section \ref{sec:examples} gives a wide choice of 
applied \pkg{lifecontingencies} examples, finally section \ref{sec:discussion} discusses package actual and prospective development and known limitations.

\section{Life contingencies statistical and financial foundations}\label{sec:statistics}

Life insurance analysis involves the calculation of statistics regarding occurrences and amounts 
of future cash flows. E.g. the insurance pure premiun (also known as benefit premium) is the present value of 
the series of future cash flows whose probability is based on the occurrence of the policyholder's life events (life 
contingencies). Therefore, life insurance actuarial mathematics grounds itself on concepts 
derived from demography and the theory of interest.\\

A life table (also called a mortality table or actuarial table) is a table
that shows how mortality affects subject of a cohort across different ages. It reports for 
each age $x$, the number of $l_x$ individualsliving at the beginning of age $x$. It represents a sequence of $l_0, l_1, \ldots, l_{\omega}$, 
where $\omega$, the terminal age, is the farthest age until which a subject of the cohort can survive. 
Life table are typically distinguished according to gender, year of birth and nationality.\\

Using a statistical perspective, a life table allows the probability distribution of the the future lifetime for a subject aged $x$, to be 
deduced. In particular, a life table allows to derive two key probability distributions: $\tilde T_x$, the future lifetime for a subject 
aged $x$ and its curtate form, $\tilde K_x$, i.e., the number of future years completed before death. Therefore, many statistics can be derived from the life table. 
A non exhaustive list follows:
\begin{itemize}
	\item $_t{p_x} = \frac{l_{x + t}}{l_x}$, the probability that someone living at age $x$ will reach age $x+t$.
	\item $_t{q_x}$, the complementary probability of $_t{p_x}$.
	\item $_t{d_x}$, the number of deaths between age $x$ and $x+t$.
	\item $_t{L_x} = \sum\limits_{k = 0}^t {{l_{x + k}}}$, the expected number of years lived by the cohort between ages $x$ and  $x+t$.  
	\item $_t{m_x} = \frac{{_t{d_x}}}{{_t{L_x}}}$, the central mortality rate between ages $x$ and  $x+t$.
	\item $e_x$, the curtate expectation of life for a subject aged $x$, $e_x = E\left( K_x \right)$ and 
	its complete form $\mathop e\limits^ \circ  _x = E\left( T_x \right)$.
\end{itemize}

The Keyfitz textbook, \cite{keyfitz2005applied}, provides an exaustive coverage about 
life table theory and practice. Life table are usually published by institutions that 
have access to large amount of reliable historical data,  like government statistics or social security bureaus. 
It is a common practice for actuaries to start from these life 
tables and to adapt them to the insurer's portfolio actual experience.

Classical financial mathematics deals with monetary amount that could be available in different times. The present value 
of a series of cash flows, reported in Formula \ref{eq:CF}, is probably the most important concept. The present value represents the current value of a 
series of monetary cash flows, $CF_t$, that will be available in different periods of time.\\
The interest rate, $i_t$, represents the measure of the price of money available in future times. 
This paper will use $i$ to express the effective (real) compound interest. It means that if $i$ is the interest 
rate, a sum of 1 monetary unit accumulates throught time according to the accumulation function, $A\left( t \right) = \left( 1 + i \right)^t$. Arrangements 
lead to discount and nominal (m-compound) interest rates as shown in Formula \ref{eq:interest}.

\begin{equation}
A \left( t \right)=\left( 1+i \right)^{t}=\left( 1-d \right )^{-t} = \left( 1+ \frac{i^{m}}{m} \right)^{t*m} = \left( 1 - \frac{d^m}{m} \right)^{-t*m}
\label{eq:interest}
\end{equation}

All financial mathematics functions (such annuities, $\bar{a}_{\lcroof{n}}$, or 
accumulated values, $s_{\lcroof{n}}$) can be written as a particular case of 
formula \ref{eq:CF}. See the classical \cite{broverman2008mathematics} textbook for further 
reference on the topic.\\

\begin{equation}
	PV = \sum\limits_{t \in T}^{} CF_t {\left( 1 + i_t \right)^{-t}}
	\label{eq:CF}
\end{equation}

Actuaries use the probabilities inherent the life table to evaluate life contingencies 
insurances. Life contingencies are themselves stochastic variables, in fact. They consist in 
present values whose amounts are not certain, since both the time of their (eventual) occurrence and their final values 
depend by events regarding the life of the policyholder (that is the reason for which they are called life contingencies). \pkg{lifecontingencies} package provides 
function to model many of such random variables, $\tilde{Z}$, and in particular their expected value, the Actuarial Present 
Value (APV). APV is certainly the most important statistic for $\tilde{Z}$ variables that actuaries
use, since it represents the average cost of the benefits the insurer guarantees to policyholders. In a P\&C context it 
would be also known as pure premim. The benefit premiums plus the loadings for expense, profits and taxes sum up to the commercial premium policyholders pay. 
Life contingencies can be either continue or discrete. \pkg{lifecontingencies} package models only discrete life contingencies, that is insured 
amounts are supposed to be due at the end of each year or fraction of year. However most continuous time life contingencies insurance are 
easily derived from the discrete form under broad assumptions as the \cite{bowers1997actuarial} textbook formulas show.

Few examples of life contingencies follow: 

\begin{enumerate}

	\item An n-year term life insurance provides payment of \$ b, if the insured dies within n years from issue. If the 
	payment is perfomed at the end of year of death, we can write $\tilde Z$ as 
	$\tilde Z = \left\{ \begin{array}{l}
	b*v^{\tilde K_x + 1},\tilde K_x \le n\\
	0,\tilde K_x > n
	\end{array} \right.$ The APV symbol is $\termins{x}{n}$. 
	
	\item A life annuity consists in a sequence of benefits paid contingent upon survival of a given life. In particular,
	 a temporary life annuity due pays a benefit  at the beginning of each period so long as the annuitant (x) survives, for up to a total of n years, 
	 or n payments. Assuming \$1 payment, we can write $\tilde Z$ as
	  $\tilde Z = a_{\left. \overline {\, \tilde K + 1 \,}\! \right| }$. Its APV expression is $\anndue{x}{n}$. 
 
 	\item An n-year pure endowment insurance grants a benefit payable at the
end of n years, if the insured survives at least n years from issue. The expression of $\tilde Z$ is 
$v^n*I\left( \tilde K_x \ge n \right)$ and its APV expression is ${}_{n}E_{x}$.

	\item A n-year endowment insurance will pay a benefit either at the earlier of the year of death or 
	the end of the n-th year, whichever occurs earlier. We can write  $\tilde Z$ as $\tilde Z = v^{\min \left( n,\tilde K_x \right)}$, while 
	its APV symbol is $\pureend{x}{n}$.

\end{enumerate}


We send interested readers to the \cite{bowers1997actuarial} textbook for formulas regarding other life contingencies 
insurances as $\lcterm{(DA)}{x}{n}$, the decreasing term life insurance, $(IA)_{x}$, the increasing term life insurance, and common 
variations on payment form arrangments like deferrment and fractional payments.

The \pkg{lifecontingencies} package provides functions that allows the actuary to evaluate the APV and to draw 
random samples from $\tilde Z$ distribution. The evaluation of 
the APV has traditionally followed three approaches: the use of commutation tables, the current payment technique and the expected value tecniques.\\ 
Commutation tables extend life table by tabulating special function of age and rate of interest whose ratios allow the actuary to evaluate APV
for standard insurances. The \cite{anderson1999commutation} paper provides a comprehensive overview of this topic. 
The \pkg{lifecontingencies} allows underlying commutation table to be printed out as further described. However, commutation table usage has become 
useless in computer era. In fact they are not enough flexible and their usage is computationally inefficient. Therefore, commutation table approach has not been used within \pkg{lifecontingencies}.\\
The current payment technique calculates the APV of a life contingencies insurance, $\bar z$, as the scalar product of three vectors: 
$\bar z = \left\langle {\left\langle {\bar c \bullet \bar v} \right\rangle  \bullet \bar p} \right\rangle$. The vector of all possible uncertain cash flows, $\bar c$, 
the vector of discount factors, $\bar v$ and the vector of cash flow probability, $\bar p$. Since the current payment technique is the the most efficient approach from a computationally side perspective, 
we have used this approach to evaluate APV. Finally, the expected value approach models $\bar z$ as the scalar product of two vector: $\bar z = \left\langle \bar{pk} \bullet \bar x \right\rangle$. $\bar{pk}$ is $Pr \left[ \tilde K = k \right]$, that is the 
probability that the future (integer) remaining years will be exactly $k$,    $\bar x$ is the amount of the cash flow due 
under the policy term if $\tilde K=k$. The latter approach has been used to define the probability distribution of the life contingency $\tilde Z$ when performing stochastic analyses.\\
An example will better clarify this concept. Consider an annuity due lasting n years. Its APV, $\anndue{x}{n}$, using the commutation tables approach is reported in Formula 
\ref{eq:anndueComm}, while Formula \ref{eq:anndueCVA} reports the APV using the current payment technique.
Finally, Formula \ref{eq:anndueEVT} calculates the APV using the expected value approach. 

\begin{equation}
	APV = \frac{N_x - N_{x + n}}{D_x}
	\label{eq:anndueComm}
\end{equation}   


\begin{equation}
APV = \sum\limits_{k = 0}^{\min \left( \omega  - x - 1,n \right)} {{p_{x,t}}} 
	\label{eq:anndueCVA}
\end{equation}

\begin{equation}
APV = \sum\limits_{k = 0}^{\omega  - x} {\Pr \left[ \tilde K_x = k \right]*{\ddot a_{\left. {\overline {\, 
 {\min \left( k,n \right)} \,}}\! \right| }}} 
 \label{eq:anndueEVT}
\end{equation}

\section{The structure of the package}\label{sec:structure}

Package \pkg{lifecontingencies} contains classes and methods to handle 
lifetables and actuarial tables conveniently.\\


The package is loaded within the R command line as follows:

<<load,keep.source=TRUE>>=
library(lifecontingencies)
@

Two main S4 classes, \cite{chambers2008software}, have been defined within the \pkg{lifecontingencies} package: 
the \code{lifetable} class and the \code{actuarialtable} class. The lifetable class is defined as follows

<<show classes,keep.source=TRUE>>=
#definition of lifetable
showClass("lifetable")
@

Class \code{actuarialtable} inherits from \code{lifetable} class adding one more slot 
dedicated to the interest rate.

<<show actuarial,keep.source=TRUE>>=
showClass("actuarialtable")
@


Beyond generic S4 classes and method there are three groups of functions: 
demographics functions, financial mathematics functions and 
actuarial mathematics functions.\\

The demographic functions group comprises the followings: 
\begin{enumerate}
	\item \code{dxt} returns deaths between age $x$ and $x+t$, $d_{x,t}$.
	\item \code{pxt} returns survival probability between age $x$ and $x+t$, $p_{x,t}$.
	\item \code{pxyt} returns the survival probability for two lifes, $d_{xy,t}$.
	\item \code{qxt} returns death probability between age $x$ and $x+t$, $q_{x,t}$.
	\item \code{qxyt} returns the survival probability for two lifes, $q_{xy,t}$.
	\item \code{Txt} returns the number of person-years lived after exact age $x$, $T_{x,t}$.
	\item \code{mxt} returns central mortality rate, $m_{x,t}$.
	\item \code{exn} returns the complete or curtate expectation of life from age $x$ to $x+n$, $e_{x,n}$.
	\item \code{rLife} returns a sample from the time until death distribution underlying 
	a life table.
	\item \code{exyt} returns the expected life time for two lifes between age $x$ and $x+t$.
	\item \code{probs2lifetable} returns a life table $l_x$ from raw one - year survival / death probabilities.
\end{enumerate}

The financial mathematics group comprises the followings:
	\begin{enumerate}
		\item \code{presentValue} returns the present value for a series of cash flows, $PV = \sum\limits_i^{}{ CF_i*v^{t_i}}$.
		\item \code{annuity} returns the present value of a annuity - certain, $a_{\lcroof{n}}$.
		\item \code{accumulatedValue} returns the future value of a series of cash flows, $s_{\lcroof{n}}$.
		\item \code{increasingAnnuity} returns the present value of an increasing annuity - certain, $(IA)_{n}$.
		\item \code{decreasingAnnuity} returns the present value of a decreasing annuity, $(DA)_{\lcroof{n}}$.
		\item \code{nominal2Real} returns the effective annual interest (discount) rate $i$ given the nominal m-periodal interest $i^(k)$ or discount $d^(k)$ rate.
		\item \code{real2Nominal} returns the m-periodal interest or discount rate given the m periods or the discount.
		\item \code{intensity2Interest} returns the intensity of interest $\delta$ given the interest rate $i$.
		\item \code{interest2Intensity} returns the interest rate $i$ given the intensity of interest $\delta$.
		\item \code{duration} returns the duration of a series of cash flows, $\sum\limits_t^{T} \frac{t*CF_{t}\left( 1 + \frac{i}{m} \right)^{ - t*m}}{P}$.
		\item \code{convexity} returns the convexity of a series of cash flows, $\sum\limits_{t}^{T} t*\left( t + \frac{1}{m} \right) * CF_t \left(1 + \frac{y}{m} \right)^{ - m*t - 2}$.
	\end{enumerate}

The actuarial mathematics group comprises the following functions, for which we report must important function:
	\begin{enumerate}
		\item \code{Axn} models one head life insurance, whose APV symbol is $\termins{x}{n}$.
		\item \code{AExn} models the n-year term insurance, whose APV symbol is $\pureend{x}{n}$.
		\item \code{Axyn} models two heads life insurances, whose APV symbol is $\lcterm{\bar{A}}{\overline{xy}}{n}$.
		\item \code{axn} models annuities, whose APV symbol is $\ddot{a}_x$.
		\item \code{axyn} models two heads annuities, whose APV symbol is $\ddot{a}_{xy}$.
		\item \code{Exn} models pure endowment, whose APV symbol is $\pureendc{x}{n}$.
		\item \code{Iaxn} models the increasing annuity, whose APV symbol is $(Ia)_{x}$.
  	\item \code{IAxn} models the increasing life insurance, whose APV symbol is $(IA)_{x}$.
    \item \code{DAxn} models the decreasing life insurance, whose APV symbol is $(DA)_{x}$.
\end{enumerate}

As general remark, standard financial and actuarial mathematics functions parameters are:
\begin{itemize}
	\item \code{x}, the policyholder's age at the policy issuance time.
	\item \code{n}, the coverage duration that could be missing if the policy lasts for the remaining lifetime. For financial mathematics 
	function it represent the lenght of the payment.
	\item \code{actuarialtable}, an actuarial table on which life insurance calculation are performed.
	\item \code{i}, the interest rate, that in some case could be time - varying.
	\item \code{k}, the frequency of payments per year (default value is 1).
\end{itemize}


\clearpage
\newpage

\section{Code and examples} \label{sec:examples}

\subsection{Classical financial mathematics example}

The \pkg{lifecontingencies} package provides functions to perform classical financial mathematics calculations.
Following examples show how to handle interest and discount rates with different compounding frequency,
how to perform present value, annuities and future values analysis calculations as long as loans amortization and bond pricing.

\subsubsection{Interest rate functions}\label{sec:finInt}

The code below shows how to switch from effective interest rates (APR) to nominal 
interest rates,  $i^{\left( m \right)} \to i$, and vice versa. Similarly, it is possible 
to work with discount rates also, that is $d^{\left( m \right)} \to d$ and 
vice versa.\\

<<interest rates functions, keep.source=TRUE>>=
#an APR of 3% is equal to a 
real2Nominal(0.03,12)
#nominal interest rate 
#while 6% annual nominal interest rate is the same of 
nominal2Real(0.06,12)

#4% effective interest rate corresponds to 
real2Nominal(0.04,4)*100
#nominal interest rate (in 100s) compounded quarterly

#an effective rate of discount of 4% is equal to a 
real2Nominal(i=0.04,k=12,type="discount")
#nominal rate of discount payable quarterly
@


\subsubsection{Present value analysis}\label{sec:pva}

Performing a project appraisal means evaluating the net present value (NPV) of all projected cash flows.
Following code examples will show NPV evaluation assuming a varying cash flow pattern (example 1), varying interest rate (example 2) 
and uncertain cash flow (example 3).
<<present value, keep.source=TRUE>>=
#varing cash flow pattern
capitals=c(-1000,200,500,700)
times=c(0,1,2,5)
ex1<-presentValue(cashFlows=capitals, timeIds=times, 
             interestRates=0.03)
#varying interest rates
ex2<-presentValue(cashFlows=capitals, timeIds=times, 
             interestRates=c( 0.04, 0.02, 0.03, 0.05))
#uncertain cash flows
ex3<-presentValue(cashFlows=capitals, timeIds=times, 
interestRates=c( 0.04, 0.02, 0.03, 0.05), probabilities=c(1,1,1,0.5))
c(ex1,ex2,ex3)
@


\subsubsection{Annuities and future values}\label{sec:annfv}

Code below shows examples of annuities ($a_{\left. {\overline {\, n \,}}\! \right| }$) 
and accumulated values ($s_{\left. {\overline {\, n \,}}\! \right| }$)  evaluations:


<<annuities, keep.source=TRUE>>=
#the PV of an annuity immediate $100 payable at the end of next 5 years at 3% is
100*annuity(i=0.03,n=5)
#while the corresponding future value is
100*accumulatedValue(i=0.03,n=5)
@

A more concrete and meaningful example follows. A man wants to save \$ 100,000 to pay for the education
of his son in 10 years time. An education fund requires the investors to deposit equal 
instalments annually at the end of each year. If interest of 0.05 is paid, how much does the man need to save each year (R) in order to meet his target?

<<savings account projection, keep.source=TRUE>>=
C=100000
R=C/accumulatedValue(i=0.05,n=10)
R
@

The fractional payments annuities represent an important class of financial contract.
An annuity with m fractional payments per period grants a payment of $\frac{1}{m}$ during 
each period. \pkg{lifecontingencies} package allows fractional annuities (${a^{\left( m \right)}}_{\left. {\overline {\, 
 n \,}}\! \right| }$) can be handled when using \code{annuity} and \code{accumulatedValue} 
functions. The present value of an annuity-immediate of 100 per quarter for 4 years, 
assuming interest to be compounded semiannually at the nominal rate of 6\% is 

<<fractional annuities, keep.source=TRUE>>=
100*4*annuity(i=nominal2Real(0.06,2),n=4,k=4)
@

\code{increasingAnnuity} and \code{decreasingAnnuity} functions handle
increasing and decreasing annuities, whose symbols are $(IA)_{x}$, $(DA)_{x}$. Code below exemplifies 
these function, assuming a ten years duration and a 3\% interest rate.

<<increasing and decreasing, keep.source=TRUE>>=
#increasing annuity example
ex1<-increasingAnnuity(i=0.03, n=10,type="due")
#decreasing annuity example
ex2<-decreasingAnnuity(i=0.03, n=10,type="immediate")
c(ex1,ex2)
@

The last example of this section exemplifies the calculation of the present value 
of a geometrically increasing annuity. We will assume each year the annuity increases its value by 3\%, 
being the interest rate is 4\% and the annuity duration being 10 years.

<<geometrically increasing annuity, keep.source=TRUE>>=
annuity(i=((1+0.04)/(1+0.03)-1),n=10)
@




\subsubsection{Loan amortization}\label{sec:loan}

\pkg{lifecontingencies} financial mathematics function allow to define the 
repayments schedule of any loan arrangment, as exemplified in this section. In the following example, let $C$ denote the loaned capital (principal), then 
assuming an interest rate $i$, the amount due to the lender at each instalment is $R = \frac{C}{a_{\left. {\overline {\, n \,}}\! \right| }}$.
Therefore the $R_t$ amount repays $I_t=C_{t-1}*i$ as interest and  $C_t=R_t-I_t$ as 
capital at each installment. Figure \ref{fig:LoanAmort} shows the end of period (EoY) balance due for a 30 - years 
duration loan, assuming a 5\% interest rate on a principal of \$ 100,000. 

<<capital amortization, keep.source=TRUE>>=
capital=100000
interest=0.05 
payments_per_year=2
rate_per_period=(1+interest)^(1/payments_per_year)-1
years=30
installment=
1/payments_per_year*capital/annuity(i=interest, n=years,k=payments_per_year)
installment	
#compute the balance due at the beginning of each period
balance_due=numeric(years*payments_per_year)
balance_due[1]=capital*(1+rate_per_period)-installment
for(i in 2:length(balance_due)) balance_due[i]=balance_due[i-1]*(1+rate_per_period)-installment
@



\begin{figure}
\begin{center}
<<label=figBalanceDue,fig=TRUE,echo=FALSE>>=
plot(x=c(1:length(balance_due)),y=balance_due, main="Loan amortization", 
		ylab="EoP balance due", xlab="year", type="l",col="steelblue")
@
\caption{Loan amortization: end of period (EoP) balance due}
\label{fig:LoanAmort}
\end{center}
\end{figure}


\subsubsection{Bond pricing}\label{sec:finbond}

Bond pricing represents another application of present value analysis. A standard bond whose 
principal (face value) will be repaid at time $T$ consists in a sequence of coupons $c_t$, priced 
according to a coupon rate $j^{\left( k \right)}$ on a principal $C$. Equation \ref{eq:bond} expresses the 
present value of a bond.

\begin{equation}
B_t = {c_t}{a^{\left( k \right)}}_{\left. {\overline {\, n \,}}\! \right| } + C{v^T}
	\label{eq:bond}
\end{equation}

Examples follow showing how \pkg{lifecontingencies} package functions can be used to 
perform bond pricing. 

<<bond pricing, keep.source=TRUE>>=
#define a function to compute bond market value
bond<-function(faceValue, couponRate, couponsPerYear, yield,maturity)
{
	out=NULL
	numberOfCF=maturity*couponsPerYear #determine the number of CF
	CFs=numeric(numberOfCF)
	payments=couponRate*faceValue/couponsPerYear #determine the coupon sum
	cf=payments*rep(1,numberOfCF)
	cf[numberOfCF]=faceValue+payments #set the last payment amount
	times=seq.int(from=1/couponsPerYear, to=maturity, by=maturity/numberOfCF)
	out=presentValue(cashFlows=cf, interestRates=yield, timeIds=times)
	return(out)
}
#coupon rate 6%, two coupons per year, face value 1000, 
#yield 5%, three years to maturity
bndEx1<-bond(1000,0.06,2,0.05,3)

#coupon rate 3%, one coupons per year, 
#face value 1000, yield 3%, three years to maturity
bndEx2<-bond(1000,0.06,1,0.06,3)
c(bndEx1, bndEx2)
@

Last financial mathematics examples show how duration and convexity of 
cash flows can be estimated by \pkg{lifecontingencies} package 
functions.\\

<<duration and convexity, keep.source=TRUE>>=
#set cash flows, times and interest rates
cashFlows=c(100,100,100,600,500,700)
timeVector=seq(1:6)
interestRate=0.03

#dollar duration
duration(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1, macaulay = FALSE)

#Macaulay duration
duration(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1, macaulay = TRUE)

#convexity
convexity(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1)
@



\clearpage
\newpage

\subsection{Lifetables and actuarial tables analysis}

\code{lifetable} and \code{actuarialtable} classes are designed to handle demographic 
and actuarial mathematics calculations. A \code{actuarialtable} class inherits from \code{lifetable} class. It has one more slot dedicated to 
the rate of interest. Both classes have been designed using the S4 R classes framework.\\
Following examples show how to initialize these classes, basic survival 
probabilities and life table analysis. 

\subsubsection{Creating lifetable and actuarialtable objects}
Lifetable objects can be created by raw \proglang{R} commands or using existing \code{data.frame} objects.
However, to build a \code{lifetable} class object three components are needed:
\begin{enumerate}
	\item The years sequence, that is an integer sequence $0,1,\ldots, \omega$. It shall 
	start from zero and going to the terminal, $\omega$, age (the age $x$ that $p_x=0$).
	\item The $l_x$ vector, that is the number of subjects living at the beginning of age $x$, i.e. the 
	number of subject at risk to die between year $x$ and $x+1$.
	\item The name of the life table.
\end{enumerate}

There are three main approaches to create a \code{lifetable} object:
\begin{enumerate}
	\item directly from the $x$ and $l_x$ vector.
	\item importing $x$ and $l_x$ from an existing \code{data.frame} object.
	\item from raw survival probabilities.
\end{enumerate}

To create a \code{lifetable} object directly we can do as code below shows

<<create a lifecontingencies object, keep.source=TRUE>>=
x_example=seq(from=0,to=9, by=1)
lx_example=c(1000,950,850,700,680,600,550,400,200,50)
exampleLt=new("lifetable",x=x_example, lx=lx_example, name="example lifetable")
@

while \code{print} and \code{show}  methods tabulate 
the x, lx, px and ex values for a given life table.

<<print - show, keep.source=TRUE>>=
print(exampleLt)
@

\code{head} and \code{tail} methods for \code{data.frame} S3 classes have also 
been implemented on \code{lifetable} classes, as shown below.

<<head and tail, keep.source=TRUE>>==
#head method
head(exampleLt)
@

Nevertheless the easiest way to create a \code{lifetable} object is to start 
from a suitable existing \code{data.frame}. It would be also the most real concrete approach 
an actuary would use to handle \code{lifetable} objects. In the following example the US Social 
Security life table for males and females as long as the Italian IPS55 tables series are 
loaded from the existing \code{demoUsa} and \code{demoIta} datasets bundled in the \pkg{lifecontingencies}
package.  

<<create from data frame, keep.source=TRUE>>=
#load USA Social Security LT
data(demoUsa) 
usaMale07=demoUsa[,c("age", "USSS2007M")]
usaMale00=demoUsa[,c("age", "USSS2000M")]
#coerce from data.frame to lifecontingencies 
#requires x and lx names
names(usaMale07)=c("x","lx")
names(usaMale00)=c("x","lx")
#apply coerce methods and changes names
usaMale07Lt<-as(usaMale07,"lifetable")
usaMale07Lt@name="USA MALES 2007"
usaMale00Lt<-as(usaMale00,"lifetable")
usaMale00Lt@name="USA MALES 2000"
#compare expected lifetimes
c(exn(usaMale00Lt,0),exn(usaMale07Lt,0))

#load Italian IPS55 tables
##males
lxIPS55M<-with(demoIta, IPS55M)
pos2Remove<-which(lxIPS55M %in% c(0,NA))
lxIPS55M<-lxIPS55M[-pos2Remove]
xIPS55M<-seq(0,length(lxIPS55M)-1,1)
##females
lxIPS55F<-with(demoIta, IPS55F)
pos2Remove<-which(lxIPS55F %in% c(0,NA))
lxIPS55F<-lxIPS55F[-pos2Remove]
xIPS55F<-seq(0,length(lxIPS55F)-1,1)
#finalize the tables
ips55M=new("lifetable",x=xIPS55M, lx=lxIPS55M, 
		name="IPS 55 Males")
ips55F=new("lifetable",x=xIPS55F, lx=lxIPS55F, 
		name="IPS 55 Females")
#compare expected lifetimes
c(exn(ips55M,0),exn(ips55F,0))
@


The last way a \code{lifetable} object can be created is from 
one year survival or death probabilities.
This feature is useful when used in conjunction with the results of 
a mortality projection method (e.g. Lee - Carter).

<<create from survival rates, keep.source=TRUE>>=
#use 2002 Italian males life tables
data(demoIta)
itaM2002<-demoIta[,c("X","SIM92")]
names(itaM2002)=c("x","lx")
itaM2002Lt<-as(itaM2002,"lifetable")
itaM2002Lt@name="IT 2002 Males"
#reconvert in data frame
itaM2002<-as(itaM2002Lt,"data.frame")
#add qx
itaM2002$qx<-1-itaM2002$px
#reduce to 20% one year death probability for ages between 20 and 60
for(i in 20:60) itaM2002$qx[itaM2002$x==i]=0.2*itaM2002$qx[itaM2002$x==i]
#otbain the reduced mortality table
itaM2002reduced<-probs2lifetable(probs=itaM2002[,"qx"], radix=100000,
		type="qx",name="IT 2002 Males reduced")
@


An \code{actuarialtable} can be easily created from a \code{lifetable} existing 
object.

<<create a actuarialtable object, keep.source=TRUE>>=
#assume 3% interest rate
exampleAct=new("actuarialtable",x=exampleLt@x, lx=exampleLt@lx, interest=0.03, 
		name="example actuarialtable")
@

Method \code{getOmega} for \code{actuarialtable} classes provides the terminal age, $\omega$.

<<method omega, keep.source=TRUE>>=
getOmega(exampleAct)
@

Method \code{print} behaves differently between \code{lifetable} objects and 
\code{actuarialtable} objects.\\ 
One year survival probability and complete expected remaining 
life until deaths is reported when \code{print} method is applied on a \code{lifetable} object.
Classical commutation functions ($D_x$, $N_x$, $C_x$, $M_x$, $R_x$) are reported 
when \code{print} method is applied on an \code{actuarialtable} object.

<<print method, keep.source=TRUE>>=
#apply method print applied on a life table
print(exampleLt)
#apply method print applied on an actuarial table
print(exampleAct)
@

Finally a \code{plot} method can be applied to a \code{lifetable} or \code{actuarialtable} object. 
Figure \ref{fig:SoaLt} plots the survival function (i.e. the plot of $x$ vs $l_x$) of the SOA illustrative 
life table.

\begin{figure}
\begin{center}
<<label=figSurvivalFunction,fig=TRUE,echo=FALSE>>=
	plot(soa08Act, type="l",col="steelblue")
@
\caption{Society of Actuaries illustrative lifetable 
underlying survival distribution function}
\label{fig:SoaLt}
\end{center}
\end{figure}







\clearpage


\subsubsection{Basic demographic analysis}


Basic demographic estimations can be performed on 
valid \code{lifetable} or \code{actuariatable} objects. 
Code below shows how ${}_{t}p_{x}$, ${}_{t}q_{x}$ and $\mathring{e}_{x:\lcroof{n}}$ 
can be obtained.

<<probability and demographics, keep.source=TRUE>>=
#using ips55M life table
#probability to survive one year, being at age 20
pxt(ips55M,20,1)
#probability to die within two years, being at age 30
qxt(ips55M,30,2) 
#expected (curtate) life time between 50 and 70 years
exn(ips55M, 50,20) 
@

Fractional survival probabilities can also be calculated according 
with linear interpolation (default value), constant force of mortality and hyperbolic Balducci's assumption, as 
\cite{bowers1997actuarial} details. We will show these concepts on the Society of Actuaries 
illustrative life table, assuming insured age to be 80 years old.\\

<<fractional ages, keep.source=TRUE>>==
data(soa08Act)
pxtLin=pxt(soa08Act,80,0.5,"linear") #linear interpolation 
pxtCnst=pxt(soa08Act,80,0.5,"constant force") #constant force of mortality
pxtHyph=pxt(soa08Act,80,0.5,"hyperbolic") #hyperbolic assumption
c(pxtLin,pxtCnst,pxtHyph)
@

Two heads survival probabilities calculations can be performed also. Code below
shows how joint survival probabilities, last survival probabilities and expected joint lifetime 
can be evaluated using \pkg{lifecontingencies} functions.

<<more than one head, keep.source=TRUE>>=
jsp=pxyt(ips55M,ips55F,x=65, y=63, t=2) #joint survival probability
lsp=pxyt(ips55M,ips55F,x=65, y=63, t=2,status="last") #last survival probability
jelt=exyt(ips55M, ips55F, x=65,y=63, status="joint") #joint expected lifetime
c(jsp,lsp,jelt)
@

\subsection{Classical actuarial mathematics examples}
Classical actuarial mathematics examples on life contingencies are presented.
The SOA illustrative life table assuming a 6\% interest rates (the same used 
in most \cite{bowers1997actuarial} examples) will be used, unless otherwise stated. Similarly, the insured 
amount (or the annuity term payment) will be \$1, unless otherwise stated.  

\subsubsection{Life insurance examples}

Following examples show the APV calculation (i.e. the lump sum benefit premium) for: 
\begin{enumerate}
	\item 10-year term life insurance for a subject aged 30 assuming 4\% interest rate, 
	$\lcterm{A}{30}{10}$.
	\item  10-year term life insurance for a subject aged 30 with benefit 
	payable at the end of month of death at 4\% interest rate,$(\lcterm{A}{30}{10})^{(m)}$.
	\item whole life insurance for a subject aged 40 assuming 4\% interest rate, $A_{40}$.
	\item 5 years deferred 10-years term life insurance for a subject aged 40 assuming  5\% interest rate, ${}_{5|10}\bar{A}_{40}$.
	\item 5 years annually decreasing term life insurance for a 
	subject aged 50 assuming  6\% interest rate, $\lcterm{(DA)}{50}{5}$.
	\item  20 years increasing term life insurance, age 40,
	$\lcterm{(IA)}{50}{5}$.
\end{enumerate}

<<life insurance 1, keep.source=TRUE>>=
#10 years term life insurance for a 40 years old insurer @ 4% interest  
lins1=Axn(soa08Act, 30,10,i=0.04)
#same as above but payable at the end of month of death
lins2=Axn(soa08Act, x=30,n=10,i=0.04,k=12)
#whole life variation @6% interest rate (implicit in SOA actuarial table) 
lins3=Axn(soa08Act, 40) 
#5-year deferred life insurance, 10 years length, 40 years old, @5% interest rate
lins4=Axn(soa08Act, x=40,n=10,m=5,i=0.05) 
#five years annually decreasing term life insurance, insured aged 50.
lins5=DAxn(soa08Act, 50,5)
#20 years term annually increasing life insurance, age 40
lins6=IAxn(soa08Act, 40,10)
c(lins1,lins2,lins3,lins4,lins5,lins6)
@

Pure endowments APV, $\pureendc{x}{n}$, examples are shown by following lines of code:

<<pure endowments, keep.source=TRUE>>=
#evaluate the APV for a n year pure endowment, age x=30, n=35, i=6%
ex1<-Exn(soa08Act, x=30, n=35, i=0.06)
#the same but @ i=3%
ex2<-Exn(soa08Act, x=30, n=35, i=0.03)
c(ex1,ex2)
@

\subsubsection{Life annuities examples}
Following examples show  APV calculations for different annuities variations.

<<annuities, keep.source=TRUE>>=
#annuity immediate
ex1<-axn(soa08Act, x=65, m=1)
#annuity due
ex2<-axn(soa08Act, x=65)
#due with monthly payments of $1000 provision
ex3<-12*1000*axn(soa08Act, x=65,k=12)
#due with montly payments of $1000 provision, 20 - years term
ex4<-12*1000*axn(soa08Act, x=65,k=12, n=20)
#immediate with monthly payments of 1000 provision, 20 - years term
ex5<-12*1000*axn(soa08Act, x=65,k=12,n=20,m=1/12)
c(ex1,ex2,ex3,ex4,ex5)
@

\subsubsection{Benefit premiums examples}
\pkg{lifecontingencies} package functions can be used to evaluate benefit premium $P$ for life contingencies 
insurance. A (level) benefit premium is defined as the actuarial present value of the 
provided coverage paid in h installments, $P=\frac{APV}{\ddot{a}_{x:\lcroof{h}}}$.

<<life insurance 2, keep.source=TRUE>>=

#Assume X, aged 30, whishes to buy a $ 250K 35-years life insurance
#premium paid annually for 15 years @2.5% interest rate.
Pa=100000*Axn(soa08Act, x=30,n=35,i=0.025)/axn(soa08Act, x=30,n=15,i=0.025)
#while if the premium is paid on a montly basis the flat benefit premium
Pm=100000*Axn(soa08Act, x=30,n=35,i=0.025)/axn(soa08Act, x=30,n=15,i=0.025,k=12)
c(Pa,Pm)
@


<<endowment insurance, keep.source=TRUE>>=
#level semiannual premium for an endowment insurance of 10000
#insured age 50, insurance term is 20 years
APV=10000*(Axn(soa08Act,50,20)+Exn(soa08Act,50,20))
P=APV/axn(soa08Act,50,20,k=2)
P
@


\subsubsection{Benefit reserves examples}

The (prospective) benefit reserve consists in the difference between the APV of future insurers' benefits payments obligations and 
the APV of projected inflows (remaining scheduled premiums). It represents the outstanding insurer's obligation to the policyholder for the underwritten insurance policy.
An example will better exemplify this concept.\\ We will evaluate the benefit reserve for a 25 years old 40 years duration life insurance of \$ 100,000, whith benefits payable 
at the end of year of death, whith level benefit premium payable at the beginning of each year. Assume 3\% of interest rate and SOA life table to apply.\\
The benefit premium $P$ is determined by equation $P \anndue{25}{40} = 100000 \lcterm{A}{25}{40}$, while 
the benefit reserve is determined by equation ${}_{k}\lcterm{V}{25+t}{n-t}=100000\lcterm{A}{25+t}{40-t}-P\anndue{25+t}{40-t}$ 
for  $t = 0 \ldots 40$.

<<life insurance benefit reserve, keep.source=TRUE>>=
P=100000*Axn(soa08Act,x=25,n=40,i=0.03)/axn(soa08Act,x=25,n=40,i=0.03)
reserveFun=function(t) return(100000*Axn(soa08Act,x=25+t,n=40-t,i=0.03)-P*
					axn(soa08Act,x=25+t,n=40-t,i=0.03))

for(t in 0:40) {if(t%%5==0) cat("At time ",t,
				" benefit reserve is ", reserveFun(t),"\n")}
			

@

Figure \ref{fig:a65Res} shows the benefit reserve for a whole life annuity due with level annual premium as 
${}_{k}V({}_{n|}\ddot{a}_{x})$. It is equal to ${}_{n|}\ddot{a}_{x}-\bar{P}({}_{n|}\bar{a}_{x}) \ddot{a}_{x+k:\lcroof{n-k}}$ when 
$x \ldots n$, $\ddot{a}_{x+k}$ otherwise. Figure \ref{fig:a65Res} displays benefit reserve 
for a 65 years old insured annuity immediate, with 40 years of deferral.

\begin{figure}[ht]
	\includegraphics[scale=0.35]{./images/fig3.png}%
	\caption{Benefit reserve for $\ddot{a}_{65}$}
	\label{fig:a65Res}%
\end{figure}


\subsubsection{Insurance and annuities on two heads}

Lifecontingencies package provides functions to evaluate life insurance and annuities on two lifes.
Following examples check the equality $a_{\overline{xy}}=a_{x}+a_{y}-a_{xy}$.


<<two heads annuity immediate, keep.source=TRUE>>=
axn(soa08Act, x=65,m=1)+axn(soa08Act, x=70,m=1)-
		axyn(soa08Act,soa08Act,	x=65,y=70,status="joint",m=1) 
axyn(soa08Act,soa08Act, x=65,y=70, status="last",m=1)
@

Reversionary annuities (annuities payable to life y upon death of x), 
$a_{x|y}=a_{y}-a_{xy}$ can also be evaluate combining \pkg{lifecontingencies} functions.

<<revesionary annuity, keep.source=TRUE>>=
#assume x aged 65, y aged 60
axn(soa08Act, x=60,m=1)-axyn(soa08Act,soa08Act, x=65,y=60,status="joint",m=1)
@

\clearpage
\newpage

\subsection{Stochastic analysis}
This last section illustrates some stochastic analysis that can be performed by 
our package, both in demographic analysis and life insurance evaluation.\\

\subsubsection{Demographic examples}

The age-until-death, both in the continuous, $\tilde T_x$,  or curtate form, $\tilde K_x$, is a stochastic variable whose 
distribution is intrinsic in the deaths within a life table. The code below shows how to sample values from the age-until-death distribution 
implicit in the SOA life table. 

<<rLife1,keep.source=TRUE>>=
data(soa08Act)
#sample 10 numbers from the Tx distribution
sample1<-rLife(n=10,object=soa08Act,x=0,type="Tx")
#sample 10 numbers from the Kx distribution
sample1<-rLife(n=10,object=soa08Act,x=0,type="Kx")
@

while code below shows how the mean of the sampled distribution is statistically equivalent 
to the expected life time, $e_{x}$.

<<rLife2,keep.source=TRUE>>=
#assume an insured aged 29
#his expected integer number of years until death is 
exn(soa08Act, x=29,type="curtate")
#check if we are sampling from a statistically equivalent distribution
t.test(x=rLife(2000,soa08Act, x=29,type="Kx"),
		mu=exn(soa08Act, x=29,type="curtate"))$p.value
#statistically not significant
@

Finally, Figure \ref{fig:deathsIPS55M} shows the deaths distribution implicit in the ips55M life table.


\begin{figure}
\begin{center}
<<label=deathsIPS55M,fig=TRUE,echo=FALSE>>=
	hist(deathsIPS55M, freq=FALSE, main="IPS55M table Kx distribution",
			xlab="Age until death",col="steelblue",nclass=100)
@
\caption{IPS55 deaths distribution function}
\label{fig:deathsIPS55M}
\end{center}
\end{figure}




\clearpage


\subsubsection{Actuarial mathematics examples}

The APV is the present value of a random variable, $\tilde Z$. $\tilde Z$ represents a composite function between the discount 
amount and indicator variables regarding the life status of the insured. We call $\tilde Z$ the present value of benefits 
random variable, $\tilde Z$.\\
Life contingencies evaluation functions return the APV as default value, since the \code{type} parameter
has "EV" (expected value) as default value. However most life contingencies actuarial mathematics 
functions are provided with a "ST" (stochastic) argument for \code{type} parameter. The 
"ST" argument allows to obtain a sample of size one from the underlying $\tilde Z$ distribution.\\
However, when samples of greater dimension are required, the most straightforward 
approach is to use the \code{rLifeContingencies} function.\\
Code below will show $\tilde Z$ variates generation from term life insurances, 
increasing life term insurances, temporary annuity,and endowment insurances respectively.
For each simulation, the unbiaseness is verified by comparing the mean of simulated variates 
with the theoretical APV. All simulations are referred to an individual aged 20 years old for an insurance duration of 40 years.
Figure \ref{fig:Zdistrs} shows the resulting $\tilde Z$ distributions.

<<Axn APV and stochastic,keep.source=TRUE>>=
numSim=50000
#term life insurance
APVAxn=Axn(soa08Act,x=25,n=40,type="EV")
APVAxn
sampleAxn=rLifeContingencies(n=numSim, lifecontingency="Axn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
t.test(x=sampleAxn,mu=APVAxn)$p.value

#increasing life insurance

APVIAxn=IAxn(soa08Act,x=25,n=40,type="EV")
APVIAxn
sampleIAxn=rLifeContingencies(n=numSim, lifecontingency="IAxn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
t.test(x=sampleIAxn,mu=APVIAxn)$p.value

#temporary annuity due

APVaxn=axn(soa08Act,x=25,n=40,type="EV")
APVaxn
sampleaxn=rLifeContingencies(n=numSim, lifecontingency="axn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
t.test(x=sampleaxn,mu=APVaxn)$p.value

#endowment insurance
APVAExn=AExn(soa08Act,x=25,n=40,type="EV")
APVAExn
sampleAExn=rLifeContingencies(n=numSim, lifecontingency="AExn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
t.test(x=sampleAExn,mu=APVAExn)$p.value
@


\begin{figure}
\begin{center}
<<label=figsim,fig=TRUE,echo=FALSE>>=
	par(mfrow=c(2,2))
	hist(sampleAxn, main="Term insurance",xlab="actuarial present value",nclass=100, col="steelblue",freq=FALSE)
	hist(sampleIAxn, main="Increasing life insurance",xlab="actuarial present value",nclass=100, col="steelblue",freq=FALSE)
	hist(sampleaxn, main="Temporary annuity due",xlab="actuarial present value",nclass=100, col="steelblue",freq=FALSE)
	hist(sampleAExn, main="Endowment insurance",xlab="actuarial present value",nclass=100, col="steelblue",freq=FALSE)
@
\caption{Life insurance stochastic variables distributions}
\label{fig:Zdistrs}
\end{center}
\end{figure}

\clearpage

The final example shows how the stochastic functions bundled in \pkg{lifecontingencies} can be used 
to make an actuarial appraisal of embedded benefits.\\

Suppose a corporation grants its employees a life insurance benefit equal to the annual salary, payable at the month of 
death. Suppose moreover that:
\begin{enumerate}
	\item The expected value and the standard deviation of the salary are \$ 50,000 and \$ 15,000 respectively and 
	salary distribution follows a log-normal distribution.
	\item The employees distribution is uniform in the range 25 - 65. Assume 65 to be retirement age.
	\item The SOA illustrative table represents an unbiased description of the population mortality.
	\item Assume no lapse to hold.
	\item The policy length is annual.
\end{enumerate}

We evaluated the best estimate, i.e. the fair value of the insured benefits according 
to IAS 19 accounting standards (another word for benefit premium),  and a risk margin measure. As risk margin measure we are using 
the difference between the 75th percentile and the best estimate. IFRS standards, \cite{ifrsInsurance}, 
define the fair value of an insurance liability as the sum of its best estimate plus its 
risk margin. We have used parallel computation facilities bundled made available by package \pkg{parallel} due 
the computationally intensive calculation. Code has been adapted from examples of \cite{mccallum2011parallel} book.

<<stochastic example full 1, keep.source=TRUE>>==
#set the various parameters
employees=500
salaryDistribution=rlnorm(n=employees,m=10.77668944,s=0.086177696) #log-normal distribution paramenters.
ageDistribution=round(runif(n=employees,min=25, max=65))
policyLength=sapply(65-ageDistribution, min,1)
#function to obtain the type of benefit
getEmployeeBenefit<-function(index,type="EV") {
	out=numeric(1)
	out=salaryDistribution[index]*Axn(actuarialtable=soa08Act, 
			x=ageDistribution[index],n=policyLength[index], 
			i=0.02,m=0,k=1, type=type)
	return(out)
}

#configure the parallel library 
#environment
require(parallel)
cl <- makeCluster(detectCores())
worker.init <- function(packages) {
	for (p in packages) {
		library(p, character.only=TRUE)
	}
	invisible(NULL)
}
clusterCall(cl, 
		worker.init, c('lifecontingencies'))
clusterExport(cl, varlist=c("employees","getEmployeeBenefit",
				"salaryDistribution","policyLength",
				"ageDistribution","soa08Act"))
#determine the best estimate of employees benefit
employeeBenefits=numeric(employees)
employeeBenefits<- parSapply(cl, 1:employees,getEmployeeBenefit, type="EV")
employeeBenefit=sum(employeeBenefits)

#determine the risk margin
nsim=100 #use 100 simulations
benefitDistribution=numeric(nsim)
yearlyBenefitSimulate<-function(i)
{
	out=numeric(1)
	expenseSimulation=numeric(employees)
	expenseSimulation=sapply(1:employees, getEmployeeBenefit, type="ST")
	out=sum(expenseSimulation)
	return(out)
}

benefitDistribution <- parSapply(cl, 1:nsim,yearlyBenefitSimulate )
stopCluster(cl)
#summarize results
riskMargin=as.numeric(quantile(benefitDistribution,.75)-employeeBenefit)
totalBookedCost=employeeBenefit+riskMargin

employeeBenefit
riskMargin
totalBookedCost
@

%aggiungere grafici delle distributioni
%commento su formula della varianza



\section{Discussion}\label{sec:discussion}

\subsection{Advantages and limitations}

The \pkg{lifecontingencies} package allows actuaries to perform demographic, financial and actuarial mathematics calculations 
within \proglang{R} software. Pricing, reserving and stochastic evaluations of life insurance contract 
can be therefore performed using \proglang{R}. Moreover, an original feature of \pkg{lifecontingencies} is the ability to generate samples variates from both life tables and 
life insurances stochastic distributions.

One of the most important limitations of \pkg{lifecontingencies} is that it handles only 
single decrement tables. Another limitation is that currently it does not allow 
continuous time life contingencies to be modelled.\\  
We expect to remove such limitations in the future. Similarly, we expect to to provide coerce methods toward packages 
specialized in demographic analysis, like \pkg{demography} and \pkg{LifeTables} packages. 
Communication with interest rates modelling packages, as \pkg{termstrcR} will be also explored. 

\subsection{Accuracy}\label{sec:disclaimer}

The accuracy of calculation have been verified by checkings with numerical examples reported in \cite{bowers1997actuarial} and 
in the lecture notes of Actuarial Mathematics the author attended years ago at Catholic University of Milan, \cite{mazzoleni2000appunti}. 
The numerical results are identical to those reported in the \cite{bowers1997actuarial} textbook for most function, with the exception of fractional payments annuities where 
the accuracy leads only to the 5th decimal. The reason of such inaccuracy is due to the fact that the package calculates the APV by directly 
sum of fractional survival probabilities, while the formulas reported 
in \cite{bowers1997actuarial} textbook uses an analytical formula.\\

Finally, it is worth to remember that the package and functions herein are provided as is, 
without any guarantee regarding the accuracy of calculations. The author disclaims any liability arising by  eventual losses 
due to direct or indirect use of this package.\\


\section*{Acknowledgments}\label{sec:acknowledgments}

The author wishes to thank all those whose suggestions contributed 
to the package enhancements. A special thank however is for Christophe Dutang, for his
suggestions and vignette revision, and Tim Riffle.

%\bibliographystyle{jss}
\bibliography{vignetteBiblio}

\end{document}
