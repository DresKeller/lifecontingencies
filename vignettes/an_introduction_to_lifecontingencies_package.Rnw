
\documentclass[nojss]{jss}
\usepackage[OT1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{lifecon}
%\usepackage{draftwatermark}
%\SetWatermarkText{Draft}
%\SetWatermarkScale{1.5}

%\usepackage{myVignette}

%\VignetteIndexEntry{An introduction to lifecontingencies package}
%\VignetteKeywords{vig1}
%\VignettePackage{lifecontingencies}
% need no \usepackage{Sweave.sty}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% declarations for jss.cls %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% almost as usual
\author{Giorgio Alfredo Spedicato, Ph.D}
\title{The \pkg{lifecontingencies} Package. A Package to Perform Financial 
and Actuarial Mathematics Calculations in \proglang{R}}

%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Giorgio Alfredo Spedicato, Ph.D} %% comma-separated
\Plaintitle{The lifecontingencies package} %% without formatting
\Shorttitle{A Package to Perform Financial and Actuarial Mathematics Calculations in \proglang{R}} %% a short title (if necessary)

%% an abstract and keywords
\Abstract{
  \pkg{lifecontingencies} \proglang{R} package performs financial and actuarial mathematics calculations to model life contingencies insurance. Its functions are able to 
  determine both the expected value and the stochastic distribution of insured benefits. Therefore they can be used both to price life insurance coverage as long as to 
  assess portfolios' risk based capital requirements.\\ 
  This paper briefly summarizes the theory regarding life contingencies, that is grounded on concepts of financial mathematics 
  and demography. 
  Then it shows how \pkg{lifecontingencies} package is a useful tool to
  perform routinary deterministic or stochastic calculations on life
  contingencies actuarial mathematics. Applied examples will be shown.
}
\Keywords{life tables, financial mathematics, actuarial mathematics, life insurance}
\Plainkeywords{life tables, financial mathematics, actuarial mathematics, life insurance} %% without formatting
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
  Giorgio Alfredo Spedicato\\
  StatisticalAdvisor\\
  Via Firenze 11
  20037 Italy\\
  Telephone: +39/334/6634384\\
  E-mail: \email{lifecontingencies@statisticaladvisor.com}\\
  URL: \url{www.statisticaladvisor.com}
}


%% for those who use Sweave please include the following line (with % symbols):
%% need no \usepackage{Sweave.sty}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\begin{document}
%\SweaveOpts{concordance=TRUE}




<<echo=FALSE, results=hide>>=
	options(prompt = "R> ", continue = "+ F ", width = 70, useFancyQuotes = FALSE)
	set.seed(123)
	numSim=200
@

\maketitle

\section{Introduction}
As of October 2012, \pkg{lifecontingencies} appears to be the first \proglang{R}
package that deals with life insurance evaluation. \proglang{R} statistical programming environment, \cite{rSoftware}, has became the reference statistical software for academics. In the industry it is now considered a valid alternative to affirmed 
commercial packages for data analysis, like as as \proglang{SAS},\cite{SAS-STAT}, \proglang{MATLAB}, \cite{MATLAB}, and \proglang{SPSS}, \cite{SPSS}.  
With respect to the insurance industry, some actuarial packages have been already available in \proglang{R}, however most of these packages mainly focus non-life actuaries. 
  In fact non - life insurance modeling uses more data analysis and applied statistical modelling than life 
 insurance does. Functions to fit loss distributions and to perform credibility 
analysis are provided within the package \pkg{actuar}, \cite{Dutang2008}. Package \pkg{actuar} represents the computational side of the classical actuarial textbook Loss Distribution, \cite{klugman2009loss}. 
The package \pkg{ChainLadder}, \cite{chainLadder}, provides functions to estimate unpaid loss reserves for P\&C insurances.
Generalized Linear Models (GLMs), widely used in non - life insurance pricing, can be fit by functions bundled in the base \proglang{R} distribution. More advanced predictive models used by actuaries, that are Generalized Additive Models for Location, Shape and Scale (GAMLSS) and 
Tweedie Regression, can be fit using specifically developed packages as \pkg{gamlss}, \cite{gamlssPkg}, and \pkg{cplm}, \cite{cplmPkg}, packages. \\
Life insurance evaluation models demographic and financial data, mainly. A Finance dedicated view exists on CRAN site that lists packages specifically tailored to financial analysis. But, few packages that 
handle demographic data have been published yet. For examples, relevant packages that perform demographic analysis are \pkg{demography}, \cite{demographyR}, and \pkg{LifeTables}, \cite{LifeTableR}.
Packages \pkg{YieldCurve}, \cite{YieldCurveR}, and \pkg{termstrc}, \cite{termstrcR}, can be used to perform interest 
rate analysis. However, no package yet exists that performs life contingencies calculations, as of May 2012.\\

Numerous commercial software specifically tailored to actuarial analysis are available in commerce, on the other hand. 
"Moses" and "Prophet" are currently the leading actuarial software for life insurance modelling. \pkg{lifecontingencies} package aims to represent the \proglang{R} 
computational side of the concepts exposed in the classical Society of Actuaries actuarial mathematics textbook, \cite{bowers1997actuarial}. Since 
life contingencies theory grounds on demography and classical financial mathematics, we have made an extensive use of \cite{mathFinAct} and 
\cite{broverman2008mathematics} textbooks as references.

The paper has been structured as follows: Section~\ref{sec:statistics} outlines the statistical and financial mathematics theory
regarding life contingencies, Section~\ref{sec:structure} overviews the structure of the \pkg{lifecontingencies} package, Section~\ref{sec:examples} gives a wide choice of 
applied \pkg{lifecontingencies} examples, finally Section~\ref{sec:discussion} discusses package actual and prospective development and known limitations.

\section{Life contingencies statistical and financial foundations}\label{sec:statistics}

Life insurance analysis involves the calculation of statistics regarding occurrences and amounts 
of future cash flows. I.e., the insurance pure premium (also known as benefit
premium) is the expected value of the distribution of the insurance benefits
future cash flows. Cash flows probability is based on the occurrence of the
policyholder's life events (life contingencies). Therefore, life insurance actuarial mathematics 
grounds itself on concepts derived from demography and the theory of interest.\\

A life table (also called a mortality table or actuarial table) is a table
that shows how mortality affects subject of a cohort across different ages. It reports for 
each age $x$, the number of $l_x$ individuals living at the beginning of age $x$. It represents a sequence of $l_0, l_1, \ldots, l_{\omega}$, 
where $\omega$, the terminal age, is the farthest age until which a subject of the cohort can survive. 
Life table are typically distinguished according to gender, year of birth and
nationality. Life tables are also commonly developed by line of business,
assurance vs annuity for example.\\

Using a statistical perspective, a life table allows the probability distribution of the the future lifetime for a subject aged $x$, to be 
deduced. In particular, a life table allows to derive two key probability distributions: $\tilde T_x$, the future lifetime for a subject 
aged $x$ and its curtate form, $\tilde K_x$, that is the number of future years completed before death. Therefore, many statistics can be derived from the life table. 
A non exhaustive list follows:
\begin{itemize}
	\item $_t{p_x} = \frac{l_{x + t}}{l_x}$, the probability that someone living at age $x$ will reach age $x+t$.
	\item $_t{q_x}$, the complementary probability of $_t{p_x}$.
	\item $_t{d_x}$, the number of deaths between age $x$ and $x+t$.
	\item $_t{L_x} = \int_0^t {l_{x + y}}dy$, the expected number of years lived by the cohort between ages $x$ and  $x+t$.  
	\item $_t{m_x} = \frac{{_t{d_x}}}{{_t{L_x}}}$, the central mortality rate between ages $x$ and  $x+t$.
	\item $e_x$, the curtate expectation of life for a 
    subject aged $x$, $e_x = E\left[ \tilde K_x \right] = \sum\limits_{k = 1}^\infty  {_k{p_x}} $.
\end{itemize}

The Keyfitz textbook, \cite{keyfitz2005applied}, provides an exhaustive coverage about 
life table theory and practice. Life table are usually published by institutions that 
have access to large amount of reliable historical data,  like government statistics or social security bureaus. 
It is a common practice for actuaries to start from these life 
tables and to adapt them to the insurer's portfolio actual experience.

Classical financial mathematics deals with monetary amount that could be available in different times. The present value 
of a series of cash flows, reported in Equation~\ref{eq:CF}, is probably the most important concept. The present value represents the current value of a 
series of monetary cash flows, $CF_t$, that will be available in different periods of time.\\
The interest rate, $i$, represents the measure of the price of money available in future times.
Parallel to the interest rate, the time value of the money can be
expressed by means of discount rates, $d = \frac{i}{1 + i}$. This
paper will use the $i$ symbol to express the effective compound interest, when
money is invested once per period. In case money is invested more frequenty, say
$m$ times per perior, each fractional period represents the interest conversion
period. During each interest conversion period, the real interest rate
$\frac{i^{\left( m \right)}}{m}$ is earned, where the $i^{\left( m \right)}$
expression defines the nominal rate of interest payable $m$ times per period.

Equation~\ref{eq:interest} combines interest and discount rates, both
on effective and nominal basis, to express how an amount of \$1 growths until 
time $t$.

\begin{equation}
A \left( t \right)=\left( 1 + i \right)^{t}=\left( 1 - d \right )^{-t} = \left( 1 + \frac{i^{m}}{m} \right)^{t * m} = \left( 1 - \frac{d^m}{m} \right)^{-t * m}
\label{eq:interest}
\end{equation}

All financial mathematics functions (such annuities, $\bar{a}_{\lcroof{n}}$, or 
accumulated values, $s_{\lcroof{n}}$) can be written as a particular case of 
Equation~\ref{eq:CF}. See the classical \cite{broverman2008mathematics} textbook for further 
reference on the topic.\\

\begin{equation}
	PV = \sum\limits_{t \in T}^{} CF_t {\left( 1 + i_t \right)^{-t}}
	\label{eq:CF}
\end{equation}

Actuaries use the probabilities inherent the life table to evaluate life contingencies 
insurances. Life contingencies are themselves stochastic variables, in fact. A life contingencies insurance can be represented by 
a series of one or more payments whose occurrence and timing, and therefore their present value, are uncertain. In fact both the time and their eventual occurrence
depend by events regarding the life of the policyholder (that is the reason for which they are called life contingencies). Since the actuarial analysis focuses on the present 
value of such uncertain payments, life contingencies insurances future payments needs to be discounted using interest rates that may be also considered stochastic. \pkg{lifecontingencies} package provides 
functions to model many of such random variables, $\tilde{Z}$, and in particular their expected value, the Actuarial Present 
Value (APV). APV is certainly the most important statistic for $\tilde{Z}$ variables that actuaries
use, since it represents the average cost of the benefits the insurer guarantees to policyholders. In a P\&C context it 
would be also known as pure premium. The benefit premiums plus the loading for expense, profits and taxes sum up to the commercial premium policyholders pay. 
Life contingencies can be either continue or discrete. \pkg{lifecontingencies} package models only discrete life contingencies, that is insured 
amounts are supposed to be due at the end of each year or fraction of year. However most continuous time life contingencies insurance are 
easily derived from the discrete form under broad assumptions as the \cite{bowers1997actuarial} textbook formulas show.

Few examples of life contingencies follow: 

\begin{enumerate}

	\item An n-year term life insurance provides payment of \$ b, if the insured dies within n years from issue. If the 
	payment is performed at the end of year of death, we can write $\tilde Z$ as $\tilde Z = \left\{ \begin{array}{l}
v^{K + 1},\,K = 0,1, \ldots ,n - 1\\
0,\,K \ge n
\end{array} \right.$ Its APV expression is $\termins{x}{n}$. 
	
	\item A life annuity consists in a sequence of benefits paid contingent upon survival of a given life. In particular,
	 a temporary life annuity due pays a benefit at the beginning of each period so long as the annuitant (x) survives, for up to a total of n years, 
	 or n payments. We can write $\tilde Z$ as
	  $\tilde Z = \left\{ \begin{array}{l}
{\ddot a_{\left. {\overline {\, 
 {K + 1} \,}}\! \right| }},\,K < n\\
{\ddot a_{\left. {\overline {\, 
 n \,}}\! \right| }},\,K \ge n
\end{array} \right.$. Its APV expression is $\anndue{x}{n}$. 
 
 	\item An n-year pure endowment insurance grants a benefit payable at the
end of n years, if the insured survives at least n years from issue. The expression of $\tilde Z$ is 
$v^n*I\left( \tilde K_x \ge n \right)$. Its APV expression is ${}_{n}E_{x}$.

	\item A n-year endowment insurance will pay a benefit either at the earlier of the year of death or 
	the end of the n-th year, whichever occurs earlier. We can write  $\tilde Z$ as $\tilde Z = \left\{ \begin{array}{l}
v^{K + 1},\,K = 0,1, \ldots ,n - 1\\
{v^n},\,K \ge n
\end{array} \right.$.
	Its APV expression is $\insend{x}{n}$.

\end{enumerate}


We send interested readers to the \cite{bowers1997actuarial} textbook for formulas regarding other life contingencies 
insurances as $\lcterm{(DA)}{x}{n}$, the decreasing term life insurance, $\lcterm{(IA)}{x}{n}$, the increasing term 
life insurance, and common variations on payment form arrangements like
deferment and fractional payments. Similarly it is possible to define insurances
and annuities depending on the survival status of two or more lives. $A_{xy}$
and $\bar{a}_{\overline{xy}}$ represent respectively the two lives joint-live
insurance and the two lives last-survivor annuity immediate APVs.

The \pkg{lifecontingencies} package provides functions that allows the actuary to evaluate the APV and to draw 
random samples from $\tilde Z$ distribution. The evaluation of 
the APV has traditionally followed three approaches: the use of commutation tables, the current payment technique and the expected value techniques.\\ 
Commutation tables extend life table by tabulating special functions of age and rate of interest. Ratios of commutation table functions allow the actuary to evaluate APV
for standard insurances. The interested reader can found a comprehensive overview of this topic in \cite{anderson1999commutation} paper. 
The \pkg{lifecontingencies} allows underlying commutation table to be printed out as further described. However, commutation table usage has become 
useless in computer era. In fact they are not enough flexible and their usage is computationally inefficient. Therefore, commutation table approach has not been used within \pkg{lifecontingencies}.\\
The current payment technique calculates the APV of a life contingencies insurance, $\bar z$, as the scalar product of three vectors: 
$\bar z = \left\langle {\left\langle {\bar c \bullet \bar v} \right\rangle  \bullet \bar p} \right\rangle$. The vector of all possible uncertain cash flows, $\bar c$, 
the vector of discount factors, $\bar v$ and the vector of cash flow probability, $\bar p$. Since the current payment technique is the the most efficient approach from a computationally side perspective, 
we have used this approach to evaluate APV. Finally, the expected value approach models $\bar z$ as the scalar product of two vector: $\bar z = \left\langle \bar{pk} \bullet \bar x \right\rangle$. $\bar{pk}$ is $Pr \left[ \tilde K = k \right]$, that is the 
probability that the future curtate lifetime to be exactly $k$ years, $\bar x$ is the amount of the cash flow due 
under the policy term if $\tilde K = k$. The latter approach has been used to define the probability distribution of the life contingency $\tilde Z$ when performing stochastic analyses.\\
An example will better clarify this concept. Consider an annuity due lasting n years. Its APV, $\anndue{x}{n}$, using the commutation tables approach is reported in Equation~\ref{eq:anndueComm}, while Equation~\ref{eq:anndueCVA} reports the APV 
using the current payment technique. Finally, Equation~\ref{eq:anndueEVT} calculates the APV using the expected value approach. 

\begin{equation}
	APV = \frac{N_x - N_{x + n}}{D_x}
	\label{eq:anndueComm}
\end{equation}   


\begin{equation}
APV = \sum\limits_{k = 0}^{\min \left( \omega  - x ,n \right)} {{}_{k}p_{x}*v^{k}} 
	\label{eq:anndueCVA}
\end{equation}

\begin{equation}
APV = \sum\limits_{k = 0}^{\omega  - x} {\Pr \left[ \tilde K_x = k \right]*{\ddot a_{\left. {\overline {\, 
 {\min \left( k, n \right)} \,}}\! \right| }}} 
 \label{eq:anndueEVT}
\end{equation}

\section{The structure of the package}\label{sec:structure}

Package \pkg{lifecontingencies} contains classes and methods to handle 
life-tables and actuarial tables conveniently.\\


The package is loaded within the \proglang{R} command line as follows:

<<load,keep.source=TRUE>>=
library("lifecontingencies")
@

Two main S4 classes, \cite{chambers2008software}, have been defined within the \pkg{lifecontingencies} package: 
the \code{lifetable} class and the \code{actuarialtable} class. The lifetable class is defined as follows

<<showClasses,keep.source=TRUE>>=
showClass("lifetable")
@

Class \code{actuarialtable} inherits from \code{lifetable} class adding one more slot 
dedicated to the interest rate.

<<showActuarial,keep.source=TRUE>>=
showClass("actuarialtable")
@


Beyond generic \code{S4} classes and method there are three groups of functions, reported 
in Table~\ref{tab:demofun}, Table~\ref{tab:finfun} and Table~\ref{tab:actfun}:
demographics functions, financial mathematics functions and actuarial
mathematics functions. Finally, Table~\ref{tab:pars} shows
\pkg{lifecontingencies} package parameters' convention.

\begin{table}[h]
\centering
\begin{tabular}{ll}
  \hline
	function & purpose\\
      \hline  \hline
	\code{dxt} & deaths between age $x$ and $x+t$, ${}_{t}d_{x}$.\\
	\code{pxt} & survival probability between age $x$ and $x+t$, ${}_{t}p_{x}$.\\
	\code{pxyzt} & survival probability for two (or more) lives, ${}_{t}p_{xy}$.\\
	\code{qxt} & death probability between age $x$ and $x+t$, ${}_{t}q_{x}$.\\
	\code{qxyzt} & death probability for two (or more) lives, ${}_{t}q_{xy}$.\\
	\code{Txt} & number of person-years lived after exact age $x$, ${}_{t}T_{x}$.\\
	\code{mxt} & central death rate, ${}_{t}m_{x}$.\\
	\code{exn} & expected lifetime between age $x$ and age $x + n$,
	${}_{n}e_{x}$.\\
	\code{rLife} & sample from the time until death distribution underlying 
	a life table.\\
    \code{rLifexyz} & sample from the time until death distribution underlying 
	 two or more life.\\
	\code{exyz} &  n-year curtate lifetime of the joint-life status.\\
	\code{probs2lifetable}  &  life table $l_x$ from raw one - year survival / death probabilities.\\
      \hline
\end{tabular}
\caption{\pkg{lifecontingencies} functions for demographic analysis.}
\label{tab:demofun}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{ll}
  \hline
	function & purpose\\
      \hline  \hline
	\code{presentValue} &   present value for a series of cash flows.\\
	\code{annuity} &  present value of a annuity - certain, $a_{\lcroof{n}}$.\\
	\code{accumulatedValue} & future value of a series of cash flows, $s_{\lcroof{n}}$.\\
	\code{increasingAnnuity} & present value of an increasing annuity - certain, $IA_{n}$.\\
	\code{decreasingAnnuity} & present value of a decreasing annuity, $DA_{\lcroof{n}}$.\\
	\code{nominal2Real} & conversion from nominal to real interest (discount) rate.\\
	\code{real2Nominal} & \code{nominal2Real} inverse.\\
	\code{intensity2Interest} & conversion to intensity of interest from the
	interest rate.\\
	\code{interest2Intensity} & \code{intensity2Interest} inverse.\\
	\code{duration} & dollar / Macaulay duration of a series of cash flows\\
	\code{convexity} & convexity of a series of cash flows.\\
      \hline
	\end{tabular}
\caption{\pkg{lifecontingencies} functions for financial mathematics.}
\label{tab:finfun}
\end{table}

\begin{table}[h]
\centering
\begin{tabular}{lll}
  \hline
	function & purpose & APV symbol\\
      \hline   \hline
	\code{Axn} & one  life insurance & $\termins{x}{n}$.\\
	\code{AExn} & the n-year  endowment & $\pureend{x}{n}$.\\
	\code{Axyzn} & two lives life insurances &
	$\lcterm{\bar{A}}{\overline{xy}}{n}$.\\
	\code{axn} & one life annuity & $\ddot{a}_x$.\\
	\code{axyzn} & two lives annuities & $\ddot{a}_{xy}$.\\
	\code{Exn} & pure endowment & $\pureendc{x}{n}$.\\

	\code{Iaxn} & increasing annuity & $Ia_{x}$.\\
	\code{IAxn} & increasing life insurance & $\lcterm{(IA)}{x}{n}$.\\
	\code{DAxn} & decreasing life insurance &  $\lcterm{(DA)}{x}{n}$.\\
      \hline
\end{tabular}
\caption{\pkg{lifecontingencies} functions for actuarial mathematics.}
\label{tab:actfun}
\end{table}

\begin{table}[h]
  \centering
  \begin{tabular}{lll}
    \hline
  parameter & significance \\
    \hline  \hline
  \code{x} & the policyholder's age.\\
  \code{n} & the coverage duration or payment duration.\\
  \code{actuarialtable} & the actuarial table.\\
  \code{i} & interest rate, that could be varying.\\
  \code{k} & the frequency of payments.\\
    \hline
\end{tabular}
\caption{\pkg{lifecontingencies} functions parameters naming conventions.}
\label{tab:pars}
\end{table}  

\clearpage



\section{Code and examples} \label{sec:examples}
The example secton of this paper is structured as follows: Section~\ref{ss:mathFin} 
deals with classical financial mathematics, Section~\ref{ss:lfActT} deals with 
creating and managing life tables and actuarial tables, Section~\ref{ss:actMath} deals with classical actuarial mathematics while Section~\ref{ss:stochastic} presents the \pkg{lifecontingencies} packages functions to perform simulation analysis.
\subsection{Classical financial mathematics example}\label{ss:mathFin}

The \pkg{lifecontingencies} package provides functions to perform classical financial mathematics calculations.
Examples that follows show how to handle interest and discount rates with different compounding frequency,
how to perform present value, annuities and future values analysis calculations as long as loans amortization and bond pricing.

\subsubsection{Interest rate functions}\label{sss:subsubInterest}

Interest rates represent the time - value of the money. However different
types of rates can be found in literature. As a remark,
Equation~\ref{eq:intdisc} displays the relationship between effective interest
rate, nominal interest rate, force of interest, effective discount rate and
nominal discount rate.

\begin{equation}
\left( 1 + i \right)^t = \left( 1 + \frac{i^{\left( m \right)}}{m} \right)^t = 
\exp \left( \delta t \right) = \left( 1 - d \right)^{ - t} = 
\left( 1 - \frac{d^{\left( m \right)}}{m} \right)^{ - t}
\label{eq:intdisc}
\end{equation}

Functions \code{interest2Discount}, \code{discount2Interest},
\code{nominal2Real}, \code{real2Nominal}, \code{interest2Intensity}, 
\code{intensity2Interest} have been based on Equation~\ref{eq:intdisc} and
inverse formulas implied therein. Throughout the paper interest rate is deemed
effective interest rate unless otherwise stated.\\

As examples, functions \code{interest2Discount} and \code{discount2Interest}
represent a convenient way to switch from interest to discount rates and
conversely.

<<ir1, keep.source=TRUE>>=
interest2Discount(0.03)
discount2Interest(interest2Discount(0.03))
@

Function \code{nominal2Real} can help to evaluate what is the effective
interest rate implied in a consumer - credit loan that offers 10\% nominal
interest rate with quarterly compounding.

<<ir1, keep.source=TRUE>>=
nominal2Real(i=0.10,4)
@


\subsubsection{Present value and internal rate of return
analysis}\label{sss:pva}

Performing a project appraisal means evaluating the net present value (NPV) of all projected cash flows.
Code below shows an example of NPV analysis 

<<npv1, keep.source=TRUE>>=
capitals=c(-1000,200,500,700)
times=c(0,1,2,5)
presentValue(cashFlows=capitals, timeIds=times,interestRates=0.03)
@
finally both interest rate varies and cash flows are uncertain the
\code{presentValue} function parameter \code{probabilities} can be properly set as following example displays.

<<npv3, keep.source=TRUE>>=
presentValue(cashFlows=capitals, timeIds=times, 
interestRates=c( 0.04, 0.02, 0.03, 0.05), 
probabilities=c(1,1,1,0.5))
@

The internal rate of return (IRR) is defined as the interest rate that make the
NPV zero. It is used to rank alternative projects alternatively to NPV. The
following example displays how to compute IRR using \pkg{lifecontingencies}
package and \proglang{R} functions.

<<npv3, keep.source=TRUE>>=
getIrr<-function(p) (presentValue(cashFlows=capitals, timeIds=times, 
interestRates=p) - 0)^2
nlm(getIrr,0.1)$estimate
@


\subsubsection{Annuities and future values}\label{sss:annfv}

An annuity (certain) is a sequence of payments with specified amount that is
present - value, while when it is valued at the end of the term of payment is is
called future values. Code below shows examples of annuities, $a_{\left.
{\overline {\, n \,}}\! \right| }$, and accumulated values, $s_{\left. {\overline {\, n \,}}\! \right| }$,  evaluations.\\
The PV of an annuity immediate \$100 payable at the end of next 5 years at 3\% is
<<ann1, keep.source=TRUE>>=
100*annuity(i=0.03,n=5)
@
while the corresponding future value is
<<ann2, keep.source=TRUE>>=
100*accumulatedValue(i=0.03,n=5)
@

Annuities and future values payable k-thly (where fractional payments of $1/k$
are received for each k-th of period) can be evaluated also.

<<ann3, keep.source=TRUE>>=
ann1<-annuity(i=0.03,n=5,k=1,type="immediate")
ann2<-annuity(i=0.03,n=5,k=12,type="immediate")
c(ann1,ann2)
@




\code{increasingAnnuity} and \code{decreasingAnnuity} functions handle
increasing and decreasing annuities, whose APV symbols are $IA_{x}$, $DA_{x}$
respectively. Assuming a ten years term and a 3\% interest rate,
examples of increasing and decreasing annuities follow.
<<ann5, keep.source=TRUE>>=
incrAnn<-increasingAnnuity(i=0.03, n=10,type="due")
decrAnn<-decreasingAnnuity(i=0.03, n=10,type="immediate")
c(incrAnn, decrAnn)
@

The last example of this section exemplifies the calculation of the present value 
of a geometrically increasing annuity. If amounts increase by
3\% and the interest rate is 4\% and its term is 10 years, the implied present
value is
<<ann6, keep.source=TRUE>>=
annuity(i=((1+0.04)/(1+0.03)-1),n=10)
@




\subsubsection{Loan amortization}\label{sss:finloan}

\pkg{lifecontingencies} financial mathematics functions allow to define the 
repayments schedule of any loan arrangement, as this section exemplifies. Let $C$ denote the loaned capital (principal), then assuming an interest rate $i$, the amount due to the lender at each installment is $R =\frac{C}{a_{\left. {\overline {\, n \,}}\! \right| }}$.
Therefore the $R_t$ amount repays $I_t = C_{t-1} * i$ as interest and  $C_t = R_t - I_t$ as 
capital at each installment. The loan installment, $R$, is initially estimated as follows

<<capAmort1, keep.source=TRUE>>=
capital=100000
interest=0.05 
payments_per_year=2
rate_per_period=(1+interest)^(1/payments_per_year)-1
years=30
R=
1/payments_per_year*capital/annuity(i=interest, 
n=years,k=payments_per_year)
R	
@
then the balance due at end of period (EoP) is calculated as follows
<<capAmort2, keep.source=TRUE>>=
balanceDue=numeric(years*payments_per_year)
balanceDue[1]=capital*(1+rate_per_period)-R
for(i in 2:length(balanceDue)) balanceDue[i]=
  balanceDue[i-1]*(1+rate_per_period)-R
@

Figure~\ref{fig:LoanAmort} shows the EoP balance due for a 30 - years 
duration loan, assuming a 5\% interest rate on a principal of \$ 100,000. 

\begin{figure}
\begin{center}

<<label=figBalanceDue,fig=TRUE,echo=FALSE>>=
plot(x=c(1:length(balanceDue)),y=balanceDue, main="Loan amortization", 
		ylab="EoP balance due", xlab="year", type="l",col="steelblue")
@
\caption{Loan amortization: EoP balance due.}
\label{fig:LoanAmort}
\end{center}
\end{figure}


\subsubsection{Bond pricing}\label{sss:finbond}

Bond pricing represents another application of present value analysis. A standard bond whose 
face value $C$ will be repaid at time $T$ consists in a sequence of
equal coupons $c_t$ paid at regular intervals and a final payment of  $C_T + c_T$. 
Equation~\ref{eq:bond} expresses the present value of a bond.

\begin{equation}
B_t = {c_t}{a^{\left( k \right)}}_{\left. {\overline {\, n \,}}\! \right| } + C{v^T}
	\label{eq:bond}
\end{equation}

Perpetuities are financial contracts that offers an indefinite sequence of
payments either at the end (perpetuity-immediate) or at the beginning of the
period (perpetuity-due).\\

Following examples show how \pkg{lifecontingencies} package elementary
functions can be combined to price bond and perpetuities.
<<BPFun1, keep.source=TRUE>>=
bond<-function(faceValue, couponRate, couponsPerYear, yield,maturity)
{
	out=NULL
	numberOfCF=maturity*couponsPerYear
	CFs=numeric(numberOfCF)
	payments=couponRate*faceValue/couponsPerYear 
	cf=payments*rep(1,numberOfCF)
	cf[numberOfCF]=faceValue+payments 
	times=seq.int(from=1/couponsPerYear, to=maturity, 
                by=maturity/numberOfCF)
	out=presentValue(cashFlows=cf, interestRates=yield, 
                   timeIds=times)
	return(out)
}

perpetuity<-function(yield, immediate=TRUE)
{
	out=NULL
	out=1/yield
	out=ifelse(immediate==TRUE,out,out*(1+yield))
	return(out)
}

@

\code{bond} and \code{perpetuity} functions defined above can be used to price
any bond, given face value, coupon rate and term, as code show displays.

<<BPFun2, keep.source=TRUE>>=
bndEx1<-bond(1000,0.06,2,0.05,3)
bndEx2<-bond(1000,0.06,2,0.06,3)
ppTy1<-perpetuity(0.1)
c(bndEx1, bndEx2,ppTy1)
@

E

\subsubsection{Duration and ALM}\label{sss:DurationAndAlm}


Duration and convexity formulas are reported in Equation~\ref{eq:duration} and
Equation~\ref{eq:convexity} respectively. They are used to perform portfolios
asset - liability management (ALM).
The interested reader could find details on \cite{mathFinAct}.
However, the example that follow shows how Macaulay duration (\code{ex1}),
modified duration (\code{ex2}) and convexity (\code{ex3}) of any series of cash flows can 
be estimated by \pkg{lifecontingencies} package functions.\\

\begin{equation}
D = \sum\limits_t^{T} \frac{t*CF_{t} \left( 1 + \frac{i}{m} \right)^{
- t * m}}{P}
\label{eq:duration}
\end{equation}


\begin{equation}
C = \sum\limits_{t}^{T} t * \left( t +
\frac{1}{m} \right) * CF_t \left( 1 + \frac{y}{m} \right)^{ - m * t - 2}
\label{eq:convexity}
\end{equation}

<<durationAndConvexity, keep.source=TRUE>>=
cashFlows=c(100,100,100,600,500,700)
timeVector=seq(1:6)
interestRate=0.03
ex1<-duration(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1, macaulay = TRUE)
ex2<-duration(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1, macaulay = FALSE)
ex3<-convexity(cashFlows=cashFlows, timeIds=timeVector, 
		i=interestRate, k = 1)
c(ex1, ex2,ex3)
@

The last example works out a small ALM problem. Suppose an insurance company has
sold a guarantee term certificate (GTC) of face value \$ 10,000, that will
mature in 7 years at a 5\% interest rate. Its final value would be:

<<almEx1, keep.source=TRUE>>=
GTCFin=10000*1.05^7
GTCFin
@

Imagine the company can hedge its liability with two alternative investments:
\begin{enumerate}
  \item A five year bond, with face value of 100 yearly coupon with coupon rate
  of 3\%.
  \item A perpetuity-immediate. As a remark, the formulas for the PV and
  Duration of the perpetuity immediate are $\frac{1}{y}$ and $\frac{1+y}{y}$
  respectively when the yield is $y$.
 \end{enumerate}
 
In order to solve the ALM problem we need to immunize the porfolio against
interest rate variation. A portfolio is immunized against parallel shift of the
yield curve if both the PV and the duration of asset is set equal to the
duration of liabilities. We start to figure out some parameters:

<<alm2, keep.source=TRUE>>=
yieldT0=0.04
durLiab=7
pvLiab=GTCFin/(1+yieldT0)^7
pvBond=bond(100,0.03,1,yieldT0,5)
durBond=duration(cashFlows=c(3,3,3,3,103),timeIds=seq(1,5),i=yieldT0)
durPpty=(1+yieldT0)/yieldT0
pvPpty=perpetuity(yieldT0)
@

%%nota: metti il sistema

Then the ALM problem is set out in a three steps problem, \cite{mathFinAct}:
\begin{enumerate}
  \item setting initial the present value of cash inflows (asset) to be equal to
  the present value of cash outflows (liabilities).
  \item setting the interest rate sensitivity (i.e., the duration) of asset to be equal to the
  interesr rate sensitivity of liabilities.
%  \item setting the convexity of asset to be greater than the convexity
%  of liabilities. In other word, this means verifying that assets decline
%  (growth) to be slow (faster) than liability decline in case of changing
%   interest rate.
\end{enumerate}

<<alm3, keep.source=TRUE>>=
a=matrix(c(durBond, durPpty,1,1),nrow=2,byrow=TRUE)
b=as.vector(c(7,1))
weights=solve(a,b)
weights
@

Vector \code{weights} displays the portfolio composition in term of bonds and
liabilities respectively. Therefore the number of bonds and perpetuities that
can be purchased is determined by 

<<alm4, keep.source=TRUE>>=
bondNum=weights[1]*pvLiab/pvBond
pptyNum=weights[2]*pvLiab/pvPpty	
bondNum
pptyNum
@

The portfolio is immunized since if interest rates suddently drops to 3\% just
after, the present value of assets comes to be greater than the present
value of liabilities. The same occurs in case of upward shift of interest rates.

<<alm5, keep.source=TRUE>>=
yieldT1low=0.03
immunizationTestLow<-(bondNum*bond(100,0.03,1,yieldT1low,5)+
			pptyNum*perpetuity(yieldT1low)>GTCFin/(1+yieldT1low)^7)
yieldT1high=0.05
immunizationTestHigh<-(bondNum*bond(100,0.03,1,yieldT1high,5)+
			pptyNum*perpetuity(yieldT1high)>GTCFin/(1+yieldT1high)^7)
immunizationTestLow
immunizationTestHigh
@

It is worth to remember that the assets allocation within the portfolio should
be rebalanced since both time and changes of interest rates changes elementary
securities' durations.

\clearpage


\subsection{Life tables and actuarial tables analysis}\label{ss:lfActT}

\code{lifetable} and \code{actuarialtable} classes are designed to handle demographic 
and actuarial mathematics calculations. A \code{actuarialtable} class inherits from \code{lifetable} class. It has one more slot dedicated to 
the rate of interest. Both classes have been designed using the \code{S4} \proglang{R} classes framework.\\
Following examples show how to initialize these classes, basic survival 
probabilities and life table analysis. 

\subsubsection{Creating lifetable and actuarialtable objects}\label{sss:creating}
Life table objects can be created by raw \proglang{R} commands or using existing \code{data.frame} objects.
However, to build a \code{lifetable} class object three components are needed:
\begin{enumerate}
	\item The years sequence, that is an integer sequence $0,1,\ldots, \omega$. It shall 
	start from zero and going to the terminal, $\omega$, age (the age $x$ that $p_x=0$).
	\item The $l_x$ vector, that is the number of subjects living at the beginning of age $x$, that is the 
	number of subject at risk to die between year $x$ and $x+1$.
	\item The name of the life table.
\end{enumerate}

There are three main approaches to create a \code{lifetable} object:
\begin{enumerate}
	\item directly from the $x$ and $l_x$ vector.
	\item importing $x$ and $l_x$ from an existing \code{data.frame} object.
	\item from raw survival probabilities.
\end{enumerate}

To create a \code{lifetable} object directly we can do as code below shows

<<createALifecontingenciesObject, keep.source=TRUE>>=
x_example=seq(from=0,to=9, by=1)
lx_example=c(1000,950,850,700,680,600,550,400,200,50)
exampleLt=new("lifetable",x=x_example, lx=lx_example, name="example lifetable")
@

while \code{print} and \code{show}  methods tabulate 
the $x$, $l_x$, ${}_{t}p_{x}$ and $e_x$ values for a given life table.

<<printShow, keep.source=TRUE>>=
print(exampleLt)
@

\code{head} and \code{tail} methods for \code{data.frame} S3 classes have also 
been implemented on \code{lifetable} classes

<<headAndTail, keep.source=TRUE>>==
head(exampleLt)
@

Nevertheless the easiest way to create a \code{lifetable} object is to start 
from a suitable existing \code{data.frame}. This will be probably the most
practical approach for working actuaries. Some tables or mortality rates have
been bundled within \pkg{lifecontingencies} package, as Table~\ref{tab:lifeTables} displays.


\begin{table}[h]
\centering
\begin{tabular}{ll}
\hline
	data set & description\\
 \hline \hline
    \code{AF92Lt} & UK AF92 life table object.\\
    \code{AM92Lt} & UK AF92 life table object.\\
    \code{demoChina} & China mortality rates from SOA website.\\
	\code{demoIta} & Various Italian life tables including RG48 and IPS55 projected
	tables.\\
    \code{demoJapan} & Japan mortality rates from SOA website.\\
    \code{demoUsa} & US Social Security life tables.\\
    \code{demoFrance} & 1990 and 2002 French life tables.\\
    \code{soa08} & SOA illustrative life table.\\
    \code{soa08Act} & SOA illustrative actuarial table at
    6\%.\\    
 \hline
\end{tabular}
\caption{\pkg{lifecontingencies} bundled life tables.}
\label{tab:lifeTables}
\end{table}


In the following example the US Social
Security life tables are loaded from the existing \code{demoUsa} data set bundled in the \pkg{lifecontingencies} package.  

<<fromDataFrame1, keep.source=TRUE>>=
data("demoUsa")
data("demoIta") 
usaMale07=demoUsa[,c("age", "USSS2007M")]
usaMale00=demoUsa[,c("age", "USSS2000M")]
names(usaMale07)=c("x","lx")
names(usaMale00)=c("x","lx")
usaMale07Lt<-as(usaMale07,"lifetable")
usaMale07Lt@name="USA MALES 2007"
usaMale00Lt<-as(usaMale00,"lifetable")
usaMale00Lt@name="USA MALES 2000"
@

The same operation can be performed on IPS55 tables bundled in the \code{demoIta} data set. The purpose of 
following example is to stress that it is important a clean $l_x$ series to be given in input to the coerce method. A "clean" 
$l_x$ series means that neither 0 nor missing values are present anywhere and the $l_x$ series to be decreasing.

<<fromDataFrame2, keep.source=TRUE>>=
lxIPS55M<-with(demoIta, IPS55M)
pos2Remove<-which(lxIPS55M %in% c(0,NA))
lxIPS55M<-lxIPS55M[-pos2Remove]
xIPS55M<-seq(0,length(lxIPS55M)-1,1)

lxIPS55F<-with(demoIta, IPS55F)
pos2Remove<-which(lxIPS55F %in% c(0,NA))
lxIPS55F<-lxIPS55F[-pos2Remove]
xIPS55F<-seq(0,length(lxIPS55F)-1,1)

ips55M=new("lifetable",x=xIPS55M, lx=lxIPS55M, 
		name="IPS 55 Males")
ips55F=new("lifetable",x=xIPS55F, lx=lxIPS55F, 
		name="IPS 55 Females")
@


The last way a \code{lifetable} object can be created is from 
one year survival or death probabilities combining the \code{probs2lifetable} function and 
\code{as.data.frame} coerce methods. Two potential applications benefit from this feature: the use of the results of 
a mortality projection method ( e.g., the Lee - Carter method, \cite{Booth2006}) and the 
creation of "cut-down" mortality tables. The latter application is exemplified in the code line that follow where 
a \code{itaM2002reduced} life table is obtained cutting down the one - year mortality rates of Italian males aged between 20 and 
60 to 20\% of its original value.

<<createFromSurvivalRates, keep.source=TRUE>>=

data("demoIta")
itaM2002<-demoIta[,c("X","SIM92")]
names(itaM2002)=c("x","lx")
itaM2002Lt<-as(itaM2002,"lifetable")
itaM2002Lt@name="IT 2002 Males"

itaM2002<-as(itaM2002Lt,"data.frame")
itaM2002$qx<-1-itaM2002$px

for(i in 20:60) itaM2002$qx[itaM2002$x==i]=0.2*itaM2002$qx[itaM2002$x==i]

itaM2002reduced<-probs2lifetable(probs=itaM2002[,"qx"], radix=100000,
		type="qx",name="IT 2002 Males reduced")
@


An \code{actuarialtable} can be easily created from a \code{lifetable} existing 
object.

<<createAnActuarialtableObject, keep.source=TRUE>>=

exampleAct=new("actuarialtable",x=exampleLt@x, lx=exampleLt@lx, 
interest=0.03, name="example actuarialtable")
@

Method \code{getOmega} for \code{actuarialtable} classes returns the terminal age, $\omega$.

<<methods1, keep.source=TRUE>>=
getOmega(exampleAct)
@

Method \code{print} behaves differently between \code{lifetable} objects and 
\code{actuarialtable} objects. In fact, one year survival probability and complete expected remaining 
life until deaths are reported when \code{print} method is applied on a \code{lifetable} object. Classical commutation functions ($D_x$, $N_x$, $C_x$, $M_x$, $R_x$) are 
print out applying \code{print} method on an \code{actuarialtable} object.

<<methods2, keep.source=TRUE>>=
print(exampleLt)
print(exampleAct)
@

Finally a \code{plot} method can be applied to a \code{lifetable} or \code{actuarialtable} object. The underlying survival function (that is the plot of $x$ vs $l_x$)
is displayed in both cases. 
Figure~\ref{fig:SoaLt} shows the \code{plot} methods applied on the Society of Actuaries (SOA) 
actuarial object, \code{soa08Act}, bundled in the \pkg{lifecontingencies} package.

<<label=figSurvivalFunctio0, echo=FALSE, keep.source=TRUE>>=
data("soa08Act")
@


\begin{figure}
\begin{center}
<<label=figSurvivalFunction,fig=TRUE,echo=FALSE>>=
	plot(soa08Act, type="l",col="steelblue")
@
\caption{SOA illustrative life table underlying survival function.}
\label{fig:SoaLt}
\end{center}
\end{figure}

\clearpage

\subsubsection{Basic demographic analysis}\label{sss:demograph}


Basic demographic estimations can be performed on 
valid \code{lifetable} or \code{actuariatable} objects. 
Code below shows how ${}_{1}p_{20}$, ${}_{2}q_{30}$ and $\mathring{e}_{50:\lcroof{20}}$ respectively
can be calculated on the IPS55 male population table 

<<probabilityAndDemographics, keep.source=TRUE>>=
demoEx1<-pxt(ips55M,20,1)
demoEx2<-qxt(ips55M,30,2) 
demoEx3<-exn(ips55M, 50,20) 
c(demoEx1,demoEx2,demoEx3)
@

Fractional survival probabilities can also be calculated using the linear interpolation (\code{pxtLin}), 
constant force of mortality (\code{pxtCnst}) and hyperbolic Balducci's assumptions (\code{pxtHyph}), as 
\cite{bowers1997actuarial} textbook details. We will show these concepts on the SOA
illustrative life table, assuming insured age to be 80 years old.\\

<<fractionalAges, keep.source=TRUE>>==
data("soa08Act")
pxtLin=pxt(soa08Act,80,0.5,"linear") 
pxtCnst=pxt(soa08Act,80,0.5,"constant force") 
pxtHyph=pxt(soa08Act,80,0.5,"hyperbolic") 
c(pxtLin,pxtCnst,pxtHyph)
@

Survival probabilities calculations on two lives can be performed also. As a
remark, two life status are defined until multiple lives survival analysis:
"joint" survival status and "last" survival status. The "joint" survival status exists until all the members are alive, while the "last" survival status exists until at least one member survives. 
Equation~\ref{eq:2headssurv} 
defines the time until death until the joint and last survival status respectively.

\begin{equation}
\begin{gathered}
  \tilde T_{xy} = \min \left( T_x,T_y \right) \hfill \\
  \tilde T_{\bar{xy}} = \max \left( T_x,T_y \right) \hfill \\ 
\end{gathered}
\label{eq:2headssurv}
\end{equation}

Following code lines show how joint survival probabilities (\code{jps}), last survival probabilities (\code{lsp}) and 
expected joint lifetime (\code{jelt}) can be evaluated using \pkg{lifecontingencies} functions.

<<moreThanOneHead, keep.source=TRUE>>=
jsp=pxyt(ips55M,ips55F,x=65, y=63, t=2)
lsp=pxyt(ips55M,ips55F,x=65, y=63, t=2,status="last") 
jelt=exyt(ips55M, ips55F, x=65,y=63, status="joint") 
c(jsp,lsp,jelt)
@

\subsection{Classical actuarial mathematics examples}\label{ss:actMath}
Classical actuarial mathematics examples on life contingencies are presented.
The SOA illustrative life table assuming a 6\% interest rates (the same used in most \cite{bowers1997actuarial} examples) will be used, unless otherwise stated. Similarly, the insured amount (or the annuity term payment) will be \$1, unless otherwise stated.  

\subsubsection{Life insurance examples}\label{sss:lifeInsurances}

Following examples show the APV calculation (that is the lump sum benefit premium) for: 
\begin{enumerate}
	\item \code{lins1}: 10-year term life insurance for a policyholder aged 30 assuming 4\% interest rate, 
	$\lcterm{A}{30}{10}$.
	\item \code{lins2}: whole life insurance for a policyholder aged 30 with
	benefit payable at the end of month of death at 4\% interest rate, $A_{30}^{(12)}$.
	\item \code{lins3}: whole life insurance for a policyholder aged 40 assuming 4\% interest rate, $A_{40}$.
	\item \code{lins4}: 5 years deferred 10-years term life insurance for a policyholder aged 40 assuming 5\% 
	interest rate, ${}_{5|10}\bar{A}_{40}$.
	\item \code{lins5}: 5 years annually decreasing term life insurance for a 
	policyholder aged 50 assuming  6\% interest rate, $\lcterm{(DA)}{50}{5}$.
	\item \code{lins6}:  10 years increasing term life insurance, age 40,
	$\lcterm{(IA)}{40}{10}$.
\end{enumerate}

<<lifeInsurance1, keep.source=TRUE>>=
lins1=Axn(soa08Act, 30,10,i=0.04)
lins2=Axn(soa08Act, x=30,i=0.04,k=12)
lins3=Axn(soa08Act, 40,i=0.04)
lins4=Axn(soa08Act, x=40,n=10,m=5,i=0.05) 
lins5=DAxn(soa08Act, 50,5)
lins6=IAxn(soa08Act, 40,10)
c(lins1,lins2,lins3,lins4,lins5,lins6)
@

Any APV depends by several parameters: the class of insurance benefit, the policyholder's age, the duration of coverage and 
the interest rate are some of them. Following lines show an interest rate sensitivity analysis on the APV of a $\pureendc{30}{25}$ pure endowment 
insurance.

<<pureEndowments, keep.source=TRUE>>=
puEnd1<-Exn(soa08Act, x=30, n=35, i=0.06)
puEnd2<-Exn(soa08Act, x=30, n=35, i=0.03)
c(puEnd1,puEnd2)
@

\subsubsection{Life annuities examples}\label{sss:annuities}
Life contingencies annuities consist in sequences of payments whose occurrence
and duration depend on $\tilde K_x$ (or $\tilde T_x$). Different types of
annuities exist, of which a selection of examples follows.
The SOA life table and a policyholder age of 65 apply in all following examples.
\begin{enumerate}
  \item \code{annEx1}: annuity immediate, $a_{65}$.
  \item  \code{annEx2}: annuity due, $\ddot{a}_{65}$.
  \item  \code{annEx3}: \$ 1,000 annuity due with monthly payment provision, $\ddot{a}_{65}^{(12)}$.
  \item  \code{annEx4}: \$ 1,000 annuity due with monthly payment provision 20 years term, $\ddot{a}_{65:\lcroof{20}}^{(12)}$.
  \item  \code{annEx5}: \$ 1,000 annuity immediate with monthly payment provision 20 years term, $a_{65:\lcroof{20}}^{(12)}$.
\end{enumerate}

<<annuities, keep.source=TRUE>>=
annEx1<-axn(soa08Act, x=65, m=1)
annEx2<-axn(soa08Act, x=65)
annEx3<-12*1000*axn(soa08Act, x=65,k=12)
annEx4<-12*1000*axn(soa08Act, x=65,k=12, n=20)
annEx5<-12*1000*axn(soa08Act, x=65,k=12,n=20,m=1/12)
c(annEx1,annEx2,annEx3,annEx4,annEx5)
@

\subsubsection{Benefit premiums examples}\label{sss:benefitPremium}
\pkg{lifecontingencies} package functions can be used to evaluate benefit premium, $P$, for life contingencies 
insurance. A (level) benefit premium is defined as the actuarial present value of the 
provided coverage paid in h installments, $P=\frac{APV}{\ddot{a}_{x:\lcroof{h}}}$. The following example displays yearly, 
\code{Pa}, and monthly, \code{Pm}, level benefit premium calculations for a \$ 250,000 35 term life insurance 
for a 30 years old policyholder, assuming the payment of premium to occur during the first 15 years.

<<lifeInsurance2, keep.source=TRUE>>=
APV=100000*Axn(soa08Act, x=30,n=35,i=0.025)
Pa=APV/axn(soa08Act, x=30,n=15,i=0.025)
Pm=APV/(12*axn(soa08Act, x=30,n=15,i=0.025,k=12))
c(Pa,Pm)
@


\subsubsection{Benefit reserves examples}\label{sss:benefitReserves}

The (prospective) benefit reserve consists in the difference between the APV of future insurers' benefits payments obligations and 
the APV of projected inflows (remaining scheduled premiums). It represents the outstanding insurer's obligation to the policyholder for the underwritten insurance policy.
An example will better exemplify this concept.\\ We will evaluate the benefit reserve for a 25 years old 40 years duration life insurance of \$ 100,000, with benefits payable 
at the end of year of death, with level benefit premium payable at the beginning of each year. Assume 3\% of interest rate and 
SOA life table to apply.\\
The benefit premium and reserve equations for this life contingency insurance are displayed in Equation~\ref{eq:benResExample1}.


\begin{equation}
\begin{gathered}
  P \anndue{25}{40} = 100000 \lcterm{A}{25}{40} \hfill \\
{}_{k}\lcterm{V}{25+t}{n-t} = 100000\lcterm{A}{25+t}{40-t} - P\anndue{25+t}{40-t} \hfill \\ 
\end{gathered}
\label{eq:benResExample1}
\end{equation}

<<lifeInsuranceBenefitReserve, keep.source=TRUE>>=
P=100000*Axn(soa08Act,x=25,n=40,i=0.03)/axn(soa08Act,x=25,n=40,i=0.03)
reserveFun=function(t) return(100000*Axn(soa08Act,x=25+t,n=40-t,i=0.03)-P*
					axn(soa08Act,x=25+t,n=40-t,i=0.03))
for(t in 0:40) {if(t%%5==0) cat("At time ",t,
				" benefit reserve is ", reserveFun(t),"\n")}
@



The calculation of the benefit reserve for a deferred annuity due is the final example of this section. We assume policyholder's age to be  25 and the annuity to be deferred at 65. The reserve equation is ${}_{n|}\ddot{a}_{x}-\bar{P}({}_{n|}\bar{a}_{x}) \ddot{a}_{x+k:\lcroof{n-k}}$ when 
$x \ldots n$, $\ddot{a}_{x+k}$ otherwise. The code below calculates the level premium in the initial part and 
the reserve function while Figure~\ref{fig:a65Res} displays the reserve function.

<<annuityReserve, keep.source=TRUE>>=
yearlyRate=12000
irate=0.02
APV=yearlyRate*axn(soa08Act, x=25, i=irate,m=65-25,k=12)
levelPremium=APV/axn(soa08Act, x=25,n=65-25,k=12)

annuityReserve<-function(t) {
	out<-NULL
	if(t<65-25) out=yearlyRate*axn(soa08Act, x=25+t, 
    i=irate,m=65-(25+t),k=12)-levelPremium*axn(soa08Act, 
              x=25+t,n=65-(25+t),k=12) else {
		out=yearlyRate*axn(soa08Act, x=25+t, i=irate,k=12)
	}
	return(out)
}

years=seq(from=0, to=getOmega(soa08Act)-25-1,by=1)
annuityRes=numeric(length(years))
for(i in years) annuityRes[i+1]=annuityReserve(i)
dataAnnuityRes<-data.frame(years=years, reserve=annuityRes)
@

\begin{figure}
\begin{center}
<<label=annuityReserveGraph,fig=TRUE,echo=FALSE>>=
plot(y=dataAnnuityRes$reserve, x=dataAnnuityRes$years,
col="steelblue", main="Deferred Annuity Benefit Reserve",
ylab="amount",xlab="years",type="l")
@
\caption{Benefit reserve for $\ddot{a}_{65}$.}
\label{fig:a65Res}
\end{center}
\end{figure}

\subsubsection{Expenses considerations}\label{sss:expenses}

The premium the policyholder is usually charged to contains an allowance for expenses 
and profit loading. Those expenses cover the policy servicing, the producers' commission. In some 
case the insurer profit load is explicitly taken into account in the benefit premium as a flat amount or 
as a percentage of final premium. In other cases an implicit profit loading is generated by using 
demographic and financial assumptions more prudential than would be necessary when pricing and reserving 
the policy. The equivalence principle can be extended to the gross premium, $G$, and expense augmented reserve,  ${}_{t}V^{E}$, considering expenses allowance 
by using Equation \ref{eq:ExpenseLoad}


\begin{equation}
\begin{gathered}
  G = APV\left(Benefits\right)+APV\left(Expenses\right) \hfill \\
 {}_{t}V^{E} = APV \left( Benefits \right) + APV \left( Expenses \right) - APV \left( Gross Premium \right)	\hfill \\ 
\end{gathered}
\label{eq:ExpenseLoad}
\end{equation}

The following example shows how to a expense loaded premium $G$ for a \$ 100,000 whole life insurance
on a 35 year old insured $100,000 A_{35}$ is calculated assuming the following: 10\% of premium expense per 
year, 25 per year of policy expense, annual maintenance expense of 2.5 per 1,000 unit of capital.\\

The equation to be solved is $G \ddot{a}_{35} = 100000 A_{35} + \left( 2.5*100000/1000 + 25 + 0.1 G \right) \ddot{a}_{35}$.
<<expAugmented, keep.code=TRUE>>=
G=(100000*Axn(soa08Act, x=35)+ 275)/(1-.1)
G
@



\subsubsection{Insurances and annuities on two lives}\label{sec:ssstwoheads}

\pkg{lifecontingencies} package provides functions designed to evaluate life insurance and annuities on two lives.
Following examples check the equality $a_{\overline{xy}} = a_{x} + a_{y} - a_{xy}$.

<<twoHeadsAnnuitImmediate, keep.source=TRUE>>=
twoLifeTables=list(maleTable=soa08Act, femaleTable=soa08Act)
ex1<-axn(soa08Act, x=65,m=1)+axn(soa08Act, x=70,m=1)-
		axyn(soa08Act,soa08Act,	x=65,y=70,status="joint",m=1) 
ex2<-axyzn(twoLifeTables, x=c(65,y=70), status="last",m=1)
round(ex1-ex2,2)
@

Reversionary annuities (annuities payable to life y upon death of x), 
$a_{x|y}=a_{y} - a_{xy}$ can also be evaluate combining \pkg{lifecontingencies} functions.

<<revesionaryAnuity, keep.source=TRUE>>=
axn(soa08Act, x=60,m=1)-axyzn(twoLifeTables, x=c(65,60),status="joint",m=1)
@

\clearpage
\newpage

\subsection{Stochastic analysis}\label{ss:stochastic}
This last section illustrates some stochastic analysis that can be performed by 
our package, both in demographic analysis and life insurance evaluation. Section~ 
\ref{sss:demo} applies stochastic analysis on demographic issues, while Section~\ref{sss:actmath} applies stochastic analysis on insurance pricing.\\

\subsubsection{Demographic examples}\label{sss:demo}

The age-until-death, both in the continuous, $\tilde T_x$,  or curtate form, $\tilde K_x$, is a stochastic variable whose 
distribution is intrinsic in the deaths within a life table. The code below shows how \code{rLife} function 
can be used to draw sample of size 10 from 
the continuous and curtate future lifetime implicit in the SOA life table. 

<<rLife1,keep.source=TRUE>>=

sample1<-rLife(n=10,object=soa08Act,x=0,type="Tx")
sample2<-rLife(n=10,object=soa08Act,x=0,type="Kx")
@

Next example shows how the mean of the sampled distribution from the curtate future lifetime for a 29 year old 
policyholder, $\tilde K_{29}$, is statistically equal to the expected life time, $e_{x}$ when \code{rLife} function is used.

<<rLife2,keep.source=TRUE>>=
exn(soa08Act, x=29,type="curtate")
t.test(x=rLife(2000,soa08Act, x=29,type="Kx"),
		mu=exn(soa08Act, x=29,type="curtate"))$p.value
deathsIPS55M<-rLife(n=numSim,ips55M, x=0, type="Kx")
@

Finally, Figure~\ref{fig:deathsIPS55M} shows the deaths distribution implicit in the ips55M life table 
generated with the aid of \code{rLife} function.

\clearpage

\begin{figure}
\begin{center}
<<label=deathsIPS55Mfig,fig=TRUE,echo=FALSE>>=
hist(deathsIPS55M, freq=FALSE, main="IPS55M Table Kx Distribution",
			xlab="Age until death",col="steelblue",nclass=100)
@
\caption{IPS55 deaths distribution function.}
\label{fig:deathsIPS55M}
\end{center}
\end{figure}





\subsubsection{Actuarial mathematics examples}\label{sss:actmath}

The APV is the present value of a random variable, $\tilde Z$. $\tilde Z$ represents a composite function between the discount 
amount and indicator variables regarding the life status of the insured. We call $\tilde Z$ the present value of benefits 
random variable, $\tilde Z$.\\
Life contingencies evaluation functions return the APV as default value, since the \code{type} parameter
has "EV" (expected value) as default value. However most life contingencies actuarial mathematics 
functions are provided with a "ST" (stochastic) argument for \code{type} parameter. The 
"ST" argument allows to obtain a sample of size one from the underlying $\tilde Z$ distribution.\\
However, when samples of greater dimension are required, the most straightforward 
approach is to use the \code{rLifeContingencies} function.\\
Code below will show $\tilde Z$ variate generation from term life insurances, 
increasing life term insurances, temporary annuity,and endowment insurances respectively.
For each example, the unbiaseness is verified by comparing the mean of simulated variate 
with the theoretical APV using a classical t - test. All examples are referred to an individual aged 20 years old for an insurance duration of 40 years.
Figure~\ref{fig:Zdistrs} shows the resulting $\tilde Z$ distributions.

<<AxnAPVAndStochastic,keep.source=TRUE>>=

APVAxn=Axn(soa08Act,x=25,n=40,type="EV")
APVAxn
sampleAxn=rLifeContingencies(n=numSim, lifecontingency="Axn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
tt1<-t.test(x=sampleAxn,mu=APVAxn)$p.value

APVIAxn=IAxn(soa08Act,x=25,n=40,type="EV")
APVIAxn
sampleIAxn=rLifeContingencies(n=numSim, lifecontingency="IAxn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
tt2<-t.test(x=sampleIAxn,mu=APVIAxn)$p.value

APVaxn=axn(soa08Act,x=25,n=40,type="EV")
APVaxn
sampleaxn=rLifeContingencies(n=numSim, lifecontingency="axn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
tt3<-t.test(x=sampleaxn,mu=APVaxn)$p.value

APVAExn=AExn(soa08Act,x=25,n=40,type="EV")
APVAExn
sampleAExn=rLifeContingencies(n=numSim, lifecontingency="AExn",
		object=soa08Act,x=25,t=40,parallel=TRUE)
tt4<-t.test(x=sampleAExn,mu=APVAExn)$p.value
c(tt1, tt2,tt3, tt4)
@


\begin{figure}
\begin{center}
<<label=figsim,fig=TRUE,echo=FALSE>>=
	par(mfrow=c(2,2))
	hist(sampleAxn, main="Term Insurance",xlab="Actuarial present value",nclass=50, col="steelblue",freq=FALSE);abline(v=APVAxn, col="red", lwd=2)
	hist(sampleIAxn, main="Increasing Life Insurance",xlab="Actuarial present value",nclass=50, col="steelblue",freq=FALSE);abline(v=APVIAxn, col="red", lwd=2)
	hist(sampleaxn, main="Temporary Annuity Due",xlab="Actuarial present value",nclass=50, col="steelblue",freq=FALSE);abline(v=APVaxn, col="red", lwd=2)
	hist(sampleAExn, main="Endowment Insurance",xlab="Actuarial present value",nclass=50, col="steelblue",freq=FALSE);abline(v=APVAExn, col="red", lwd=2)
@
\caption{Life insurance stochastic variables distributions. Red vertical line represents APV.}
\label{fig:Zdistrs}
\end{center}
\end{figure}

\clearpage

The final example shows how the stochastic functions bundled in \pkg{lifecontingencies} can be used to make an actuarial appraisal of embedded benefits as following example shows.\\
Suppose a corporation grants its employees a life insurance benefit equal to the annual salary, payable at the month of 
death. Suppose moreover that:
\begin{enumerate}
	\item The expected value and the standard deviation of the salary are \$ 50,000 and \$ 15,000 respectively and 
	salary distribution follows a log-normal distribution.
	\item The employees distribution is uniform in the range 25 - 65. Assume 65 to be retirement age.
	\item The SOA illustrative table represents an unbiased description of the population mortality.
	\item Assume no lapse to hold.
	\item The policy length is annual.
\end{enumerate}

We evaluated the best estimate, that is the fair value of the insured benefits according 
to IAS 19 accounting standards (another word for benefit premium),  and a risk margin measure. As risk margin measure we are using 
the difference between the 75th percentile and the best estimate. IFRS standards, \cite{ifrsInsurance}, 
define the fair value of an insurance liability as the sum of its best estimate plus its 
risk margin.\\

In the initial part of the example, we set out the parameter of the model and configure the  parallel computation facility available by the package \pkg{parallel}. The code parallelization has been adapted from examples found in \cite{mccallum2011parallel} textbook.

<<stochasticExampleFull1, keep.source=TRUE>>==
nsim=100
employees=500
salaryDistribution=rlnorm(n=employees,m=10.77668944,s=0.086177696)
ageDistribution=round(runif(n=employees,min=25, max=65))
policyLength=sapply(65-ageDistribution, min,1)

getEmployeeBenefit<-function(index,type="EV") {
	out=numeric(1)
	out=salaryDistribution[index]*Axn(actuarialtable=soa08Act, 
			x=ageDistribution[index],n=policyLength[index], 
			i=0.02,m=0,k=1, type=type)
	return(out)
}

require(parallel)
cl <- makeCluster(detectCores())
worker.init <- function(packages) {
	for (p in packages) {
		library(p, character.only=TRUE)
	}
	invisible(NULL)
}
clusterCall(cl, 
		worker.init, c('lifecontingencies'))
clusterExport(cl, varlist=c("employees","getEmployeeBenefit",
				"salaryDistribution","policyLength",
				"ageDistribution","soa08Act"))
@
Then we perform best estimate and risk margin calculations.

<<stochasticExampleFull2, keep.source=TRUE>>==
employeeBenefits=numeric(employees)
employeeBenefits<- parSapply(cl, 1:employees,getEmployeeBenefit, type="EV")
employeeBenefit=sum(employeeBenefits)



benefitDistribution=numeric(nsim)
yearlyBenefitSimulate<-function(i)
{
	out=numeric(1)
	expenseSimulation=numeric(employees)
	expenseSimulation=sapply(1:employees, getEmployeeBenefit, type="ST")
	out=sum(expenseSimulation)
	return(out)
}

benefitDistribution <- parSapply(cl, 1:nsim,yearlyBenefitSimulate )
stopCluster(cl)

riskMargin=as.numeric(quantile(benefitDistribution,.75)-employeeBenefit)
totalBookedCost=employeeBenefit+riskMargin

employeeBenefit
riskMargin
totalBookedCost
@


\section{Discussion}\label{sec:discussion}

\subsection{Advantages and limitations}

The \pkg{lifecontingencies} package allows actuaries to perform demographic, financial and actuarial mathematics calculations 
within \proglang{R} software. Pricing, reserving and stochastic evaluations of life insurance contract 
can be therefore performed using \proglang{R}. Moreover, an original feature of \pkg{lifecontingencies} is the ability to generate samples variate from both life tables and 
life insurances stochastic distributions.

One of the most important limitations of \pkg{lifecontingencies} is that it handles only 
single decrements tables. Another limitation is that currently it does not allow 
continuous time life contingencies to be modeled.\\  
We expect to remove such limitations in the future. Similarly, we expect to to provide coerce methods toward packages 
specialized in demographic analysis, like \pkg{demography} and \pkg{LifeTables} packages. 
Communication with interest rates modelling packages, as \pkg{termstrcR} will be also explored. 

\subsection{Accuracy}\label{sec:disclaimer}

The accuracy of calculation have been verified by checking with numerical examples reported in \cite{bowers1997actuarial} and 
in the lecture notes of Actuarial Mathematics the author attended years ago at Catholic University of Milan, \cite{mazzoleni2000appunti}. 
The numerical results are identical to those reported in the \cite{bowers1997actuarial} textbook for most function, with the exception of fractional payments annuities where 
the accuracy leads only to the 5th decimal. The reason of such inaccuracy is due to the fact that the package calculates the APV by directly 
sum of fractional survival probabilities, while the formulas reported 
in \cite{bowers1997actuarial} textbook uses an analytical formula.\\

Finally, it is worth to remember that the package and functions herein are provided as is, 
without any guarantee regarding the accuracy of calculations. The author disclaims any liability arising by  eventual losses 
due to direct or indirect use of this package.\\


\section*{Acknowledgments}\label{sec:acknowledgments}

The author wishes to thank all those whose suggestions contributed 
to the package enhancements. A special thank however is for Christophe Dutang, for his
suggestions and vignette revision, and Tim Riffle.

%\bibliographystyle{jss}
\bibliography{vignetteBiblio}

\end{document}
